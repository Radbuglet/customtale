// Generated by `customtale-protocol-tools`

#![allow(non_camel_case_types)]
#![allow(non_snake_case)]

use std::fmt;

use bytes::{Bytes, BytesMut};
use uuid::Uuid;

use crate::serde::*;

bitflags::bitflags! {
    #[derive(Debug, Copy, Clone, Hash, Eq, PartialEq)]
    pub struct PacketCategory: u32 {
        const ASSET_EDITOR = 1 << 0;
        const ASSETS = 1 << 1;
        const AUTH = 1 << 2;
        const BUILDER_TOOLS = 1 << 3;
        const CAMERA = 1 << 4;
        const CONNECTION = 1 << 5;
        const ENTITIES = 1 << 6;
        const INTERACTION = 1 << 7;
        const INTERFACE = 1 << 8;
        const INVENTORY = 1 << 9;
        const MACHINIMA = 1 << 10;
        const PLAYER = 1 << 11;
        const SERVER_ACCESS = 1 << 12;
        const SETUP = 1 << 13;
        const WINDOW = 1 << 14;
        const WORLD = 1 << 15;
        const WORLD_MAP = 1 << 16;
    }
}

pub trait Packet: Into<AnyPacket> + fmt::Debug + Clone + Serde {
    const DESCRIPTOR: &'static PacketDescriptor;
}

#[derive(Debug, Clone)]
pub struct PacketDescriptor {
    pub name: &'static str,
    pub id: u32,
    pub is_compressed: bool,
    pub max_size: u32,
    pub category: PacketCategory,
}

impl fmt::Display for PacketDescriptor {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}({})", self.name, self.id)
    }
}

macro_rules! define_packets {
    (
        $($name:ident),*$(,)?
    ) => {
        #[derive(Debug, Clone)]
        pub enum AnyPacket {
            $($name (Box<$name>),)*
        }

        impl AnyPacket {
            pub const fn descriptor_for(id: u32) -> Option<&'static PacketDescriptor> {
                $(
                    if id == <self::$name as Packet>::DESCRIPTOR.id {
                        return Some(<self::$name as Packet>::DESCRIPTOR);
                    }
                )*

                None
            }

            pub fn decode(id: u32, contents: Bytes) -> anyhow::Result<Self> {
                $(
                    if id == <self::$name as Packet>::DESCRIPTOR.id {
                        return <self::$name as Serde>::decode(contents).map(Into::into);
                    }
                )*

                anyhow::bail!("unknown packet id {id:?}")
            }

            pub fn descriptor(&self) -> &'static PacketDescriptor {
                match self {
                    $(Self::$name(_) => <self::$name as Packet>::DESCRIPTOR,)*
                }
            }

            pub fn encode(&self, target: &mut BytesMut) -> anyhow::Result<()> {
                match self {
                    $(Self::$name(v) => Serde::encode(v, target),)*
                }
            }
        }

        $(
            impl From<self::$name> for AnyPacket {
                fn from(packet: self::$name) -> Self {
                    AnyPacket::$name(Box::new(packet))
                }
            }

            impl From<Box<self::$name>> for AnyPacket {
                fn from(packet: Box<self::$name>) -> Self {
                    AnyPacket::$name(packet)
                }
            }
        )*
    };
}
define_packets! {    Connect,
    Disconnect,
    Ping,
    Pong,
    Status,
    AuthGrant,
    AuthToken,
    ServerAuthToken,
    ConnectAccept,
    PasswordResponse,
    PasswordAccepted,
    PasswordRejected,
    ClientReferral,
    WorldSettings,
    WorldLoadProgress,
    WorldLoadFinished,
    RequestAssets,
    AssetInitialize,
    AssetPart,
    AssetFinalize,
    RemoveAssets,
    RequestCommonAssetsRebuild,
    SetUpdateRate,
    SetTimeDilation,
    UpdateFeatures,
    ViewRadius,
    PlayerOptions,
    ServerTags,
    UpdateBlockTypes,
    UpdateBlockHitboxes,
    UpdateBlockSoundSets,
    UpdateItemSoundSets,
    UpdateBlockParticleSets,
    UpdateBlockBreakingDecals,
    UpdateBlockSets,
    UpdateWeathers,
    UpdateTrails,
    UpdateParticleSystems,
    UpdateParticleSpawners,
    UpdateEntityEffects,
    UpdateItemPlayerAnimations,
    UpdateModelvfxs,
    UpdateItems,
    UpdateItemQualities,
    UpdateItemCategories,
    UpdateItemReticles,
    UpdateFieldcraftCategories,
    UpdateResourceTypes,
    UpdateRecipes,
    UpdateEnvironments,
    UpdateAmbienceFX,
    UpdateFluidFX,
    UpdateTranslations,
    UpdateSoundEvents,
    UpdateInteractions,
    CameraShakeEffect,
    UpdateRootInteractions,
    UpdateUnarmedInteractions,
    TrackOrUpdateObjective,
    UntrackObjective,
    UpdateObjectiveTask,
    UpdateEntityStatTypes,
    UpdateEntityUIComponents,
    UpdateHitboxCollisionConfig,
    UpdateRepulsionConfig,
    UpdateViewBobbing,
    UpdateCameraShake,
    UpdateBlockGroups,
    UpdateSoundSets,
    UpdateAudioCategories,
    UpdateReverbEffects,
    UpdateEqualizerEffects,
    UpdateFluids,
    UpdateTagPatterns,
    UpdateProjectileConfigs,
    SetClientId,
    SetGameMode,
    SetMovementStates,
    SetBlockPlacementOverride,
    JoinWorld,
    ClientReady,
    LoadHotbar,
    SaveHotbar,
    ClientMovement,
    ClientTeleport,
    UpdateMovementSettings,
    MouseInteraction,
    DamageInfo,
    ReticleEvent,
    DisplayDebug,
    ClearDebugShapes,
    SyncPlayerPreferences,
    ClientPlaceBlock,
    UpdateMemoriesFeatureStatus,
    RemoveMapMarker,
    SetChunk,
    SetChunkHeightmap,
    SetChunkTintmap,
    SetChunkEnvironments,
    UnloadChunk,
    SetFluids,
    ServerSetBlock,
    ServerSetBlocks,
    ServerSetFluid,
    ServerSetFluids,
    UpdateBlockDamage,
    UpdateTimeSettings,
    UpdateTime,
    UpdateEditorTimeOverride,
    ClearEditorTimeOverride,
    UpdateWeather,
    UpdateEditorWeatherOverride,
    UpdateEnvironmentMusic,
    SpawnParticleSystem,
    SpawnBlockParticleSystem,
    PlaySoundEvent2D,
    PlaySoundEvent3D,
    PlaySoundEventEntity,
    UpdateSleepState,
    SetPaused,
    ServerSetPaused,
    SetEntitySeed,
    EntityUpdates,
    PlayAnimation,
    ChangeVelocity,
    ApplyKnockback,
    SpawnModelParticles,
    MountMovement,
    UpdatePlayerInventory,
    SetCreativeItem,
    DropCreativeItem,
    SmartGiveCreativeItem,
    DropItemStack,
    MoveItemStack,
    SmartMoveItemStack,
    SetActiveSlot,
    SwitchHotbarBlockSet,
    InventoryAction,
    OpenWindow,
    UpdateWindow,
    CloseWindow,
    SendWindowAction,
    ClientOpenWindow,
    ServerMessage,
    ChatMessage,
    Notification,
    KillFeedMessage,
    ShowEventTitle,
    HideEventTitle,
    SetPage,
    CustomHud,
    CustomPage,
    CustomPageEvent,
    EditorBlocksChange,
    ServerInfo,
    AddToServerPlayerList,
    RemoveFromServerPlayerList,
    UpdateServerPlayerList,
    UpdateServerPlayerListPing,
    UpdateKnownRecipes,
    UpdatePortal,
    UpdateVisibleHudComponents,
    ResetUserInterfaceState,
    UpdateLanguage,
    WorldSavingStatus,
    OpenChatWithCommand,
    UpdateWorldMapSettings,
    UpdateWorldMap,
    ClearWorldMap,
    UpdateWorldMapVisible,
    TeleportToWorldMapMarker,
    TeleportToWorldMapPosition,
    RequestServerAccess,
    UpdateServerAccess,
    SetServerAccess,
    RequestMachinimaActorModel,
    SetMachinimaActorModel,
    UpdateMachinimaScene,
    SetServerCamera,
    RequestFlyCameraMode,
    SetFlyCameraMode,
    SyncInteractionChains,
    CancelInteractionChain,
    PlayInteractionFor,
    MountNPC,
    DismountNPC,
    FailureReply,
    SuccessReply,
    AssetEditorInitialize,
    AssetEditorAuthorization,
    AssetEditorCapabilities,
    AssetEditorSetupSchemas,
    AssetEditorSetupAssetTypes,
    AssetEditorCreateDirectory,
    AssetEditorDeleteDirectory,
    AssetEditorRenameDirectory,
    AssetEditorFetchAsset,
    AssetEditorFetchJsonAssetWithParents,
    AssetEditorFetchAssetReply,
    AssetEditorFetchJsonAssetWithParentsReply,
    AssetEditorAssetPackSetup,
    AssetEditorUpdateAssetPack,
    AssetEditorCreateAssetPack,
    AssetEditorDeleteAssetPack,
    AssetEditorEnableAssetPack,
    AssetEditorAssetListSetup,
    AssetEditorAssetListUpdate,
    AssetEditorRequestChildrenList,
    AssetEditorRequestChildrenListReply,
    AssetEditorUpdateJsonAsset,
    AssetEditorRebuildCaches,
    AssetEditorUpdateAsset,
    AssetEditorJsonAssetUpdated,
    AssetEditorAssetUpdated,
    AssetEditorCreateAsset,
    AssetEditorRenameAsset,
    AssetEditorDeleteAsset,
    AssetEditorDiscardChanges,
    AssetEditorFetchAutoCompleteData,
    AssetEditorFetchAutoCompleteDataReply,
    AssetEditorRequestDataset,
    AssetEditorRequestDatasetReply,
    AssetEditorActivateButton,
    AssetEditorSelectAsset,
    AssetEditorPopupNotification,
    AssetEditorFetchLastModifiedAssets,
    AssetEditorLastModifiedAssets,
    AssetEditorModifiedAssetsCount,
    AssetEditorSubscribeModifiedAssetsChanges,
    AssetEditorExportAssets,
    AssetEditorExportAssetInitialize,
    AssetEditorExportAssetPart,
    AssetEditorExportAssetFinalize,
    AssetEditorExportDeleteAssets,
    AssetEditorExportComplete,
    AssetEditorUndoChanges,
    AssetEditorRedoChanges,
    AssetEditorUndoRedoReply,
    AssetEditorSetGameTime,
    AssetEditorUpdateSecondsPerGameDay,
    AssetEditorUpdateWeatherPreviewLock,
    AssetEditorUpdateModelPreview,
    UpdateSunSettings,
    UpdatePostFxSettings,
    BuilderToolArgUpdate,
    BuilderToolEntityAction,
    BuilderToolSetEntityTransform,
    BuilderToolExtrudeAction,
    BuilderToolStackArea,
    BuilderToolSelectionTransform,
    BuilderToolRotateClipboard,
    BuilderToolPasteClipboard,
    BuilderToolSetTransformationModeState,
    BuilderToolSelectionUpdate,
    BuilderToolSelectionToolAskForClipboard,
    BuilderToolSelectionToolReplyWithClipboard,
    BuilderToolGeneralAction,
    BuilderToolOnUseInteraction,
    BuilderToolLineAction,
    BuilderToolShowAnchor,
    BuilderToolHideAnchors,
    PrefabUnselectPrefab,
    BuilderToolsSetSoundSet,
    BuilderToolLaserPointer,
    BuilderToolSetEntityScale,
    BuilderToolSetEntityPickupEnabled,
    BuilderToolSetEntityLight,
    BuilderToolSetNPCDebug,
}

codec! {
    pub struct Connect {
        pub r#protocolCrc: u32,
        pub r#protocolBuildNumber: u32,
        pub r#clientVersion: String
            => FixedSizeStringCodec::new(20),
        pub r#clientType: ClientType,
        pub r#uuid: Uuid,
        pub r#username: String
            => VarStringCodec::new(16),
        pub r#identityToken: Option<String>
            => VarStringCodec::new(8192).nullable_variable(),
        pub r#language: String
            => VarStringCodec::new(16),
        pub r#referralData: Option<Bytes>
            => VarByteArrayCodec::new(4096).nullable_variable(),
        pub r#referralSource: Option<HostAddress>,
    }
}

impl Packet for Connect {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "Connect",
        id: 0,
        is_compressed: false,
        max_size: 38013,
        category: PacketCategory::CONNECTION,
    };
}

codec! {
    pub enum ClientType {
        r#Game,
        r#Editor,
    }
}

codec! {
    pub struct HostAddress {
        pub r#host: String
            => VarStringCodec::new(256),
        pub r#port: u16,
    }
}

codec! {
    pub struct Disconnect {
        pub r#reason: Option<String>,
        pub r#type: DisconnectType,
    }
}

impl Packet for Disconnect {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "Disconnect",
        id: 1,
        is_compressed: false,
        max_size: 16384007,
        category: PacketCategory::CONNECTION,
    };
}

codec! {
    pub enum DisconnectType {
        r#Disconnect,
        r#Crash,
    }
}

codec! {
    pub struct Ping {
        pub r#id: u32,
        pub r#time: Option<InstantData>,
        pub r#lastPingValueRaw: u32,
        pub r#lastPingValueDirect: u32,
        pub r#lastPingValueTick: u32,
    }
}

impl Packet for Ping {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "Ping",
        id: 2,
        is_compressed: false,
        max_size: 29,
        category: PacketCategory::CONNECTION,
    };
}

codec! {
    pub struct InstantData {
        @small = true;
        pub r#seconds: u64,
        pub r#nanos: u32,
    }
}

codec! {
    pub struct Pong {
        pub r#id: u32,
        pub r#time: Option<InstantData>,
        pub r#type: PongType,
        pub r#packetQueueSize: u16,
    }
}

impl Packet for Pong {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "Pong",
        id: 3,
        is_compressed: false,
        max_size: 20,
        category: PacketCategory::CONNECTION,
    };
}

codec! {
    pub enum PongType {
        r#Raw,
        r#Direct,
        r#Tick,
    }
}

codec! {
    pub struct Status {
        pub r#name: Option<String>,
        pub r#motd: Option<String>,
        pub r#playerCount: u32,
        pub r#maxPlayers: u32,
    }
}

impl Packet for Status {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "Status",
        id: 10,
        is_compressed: false,
        max_size: 2587,
        category: PacketCategory::AUTH,
    };
}

codec! {
    pub struct AuthGrant {
        pub r#authorizationGrant: Option<String>,
        pub r#serverIdentityToken: Option<String>,
    }
}

impl Packet for AuthGrant {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "AuthGrant",
        id: 11,
        is_compressed: false,
        max_size: 49171,
        category: PacketCategory::AUTH,
    };
}

codec! {
    pub struct AuthToken {
        pub r#accessToken: Option<String>,
        pub r#serverAuthorizationGrant: Option<String>,
    }
}

impl Packet for AuthToken {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "AuthToken",
        id: 12,
        is_compressed: false,
        max_size: 49171,
        category: PacketCategory::AUTH,
    };
}

codec! {
    pub struct ServerAuthToken {
        pub r#serverAccessToken: Option<String>,
        pub r#passwordChallenge: Option<Vec<u8>>,
    }
}

impl Packet for ServerAuthToken {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "ServerAuthToken",
        id: 13,
        is_compressed: false,
        max_size: 32851,
        category: PacketCategory::AUTH,
    };
}

codec! {
    pub struct ConnectAccept {
        pub r#passwordChallenge: Option<Vec<u8>>,
    }
}

impl Packet for ConnectAccept {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "ConnectAccept",
        id: 14,
        is_compressed: false,
        max_size: 70,
        category: PacketCategory::AUTH,
    };
}

codec! {
    pub struct PasswordResponse {
        pub r#hash: Option<Vec<u8>>,
    }
}

impl Packet for PasswordResponse {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "PasswordResponse",
        id: 15,
        is_compressed: false,
        max_size: 70,
        category: PacketCategory::AUTH,
    };
}

codec! {
    pub struct PasswordAccepted {
    }
}

impl Packet for PasswordAccepted {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "PasswordAccepted",
        id: 16,
        is_compressed: false,
        max_size: 0,
        category: PacketCategory::AUTH,
    };
}

codec! {
    pub struct PasswordRejected {
        pub r#newChallenge: Option<Vec<u8>>,
        pub r#attemptsRemaining: u32,
    }
}

impl Packet for PasswordRejected {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "PasswordRejected",
        id: 17,
        is_compressed: false,
        max_size: 74,
        category: PacketCategory::AUTH,
    };
}

codec! {
    pub struct ClientReferral {
        pub r#hostTo: Option<HostAddress>,
        pub r#data: Option<Vec<u8>>,
    }
}

impl Packet for ClientReferral {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "ClientReferral",
        id: 18,
        is_compressed: false,
        max_size: 5141,
        category: PacketCategory::AUTH,
    };
}

codec! {
    pub struct WorldSettings {
        pub r#worldHeight: u32,
        pub r#requiredAssets: Option<Vec<Asset>>,
    }
}

impl Packet for WorldSettings {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "WorldSettings",
        id: 20,
        is_compressed: true,
        max_size: 1677721600,
        category: PacketCategory::SETUP,
    };
}

codec! {
    pub struct Asset {
        pub r#hash: String
            => FixedSizeStringCodec::new(64),
        pub r#name: String
            => VarStringCodec::new(512),
    }
}

codec! {
    pub struct WorldLoadProgress {
        pub r#status: Option<String>,
        pub r#percentComplete: u32,
        pub r#percentCompleteSubitem: u32,
    }
}

impl Packet for WorldLoadProgress {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "WorldLoadProgress",
        id: 21,
        is_compressed: false,
        max_size: 16384014,
        category: PacketCategory::SETUP,
    };
}

codec! {
    pub struct WorldLoadFinished {
    }
}

impl Packet for WorldLoadFinished {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "WorldLoadFinished",
        id: 22,
        is_compressed: false,
        max_size: 0,
        category: PacketCategory::SETUP,
    };
}

codec! {
    pub struct RequestAssets {
        pub r#assets: Option<Vec<Asset>>,
    }
}

impl Packet for RequestAssets {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "RequestAssets",
        id: 23,
        is_compressed: true,
        max_size: 1677721600,
        category: PacketCategory::SETUP,
    };
}

codec! {
    pub struct AssetInitialize {
        pub r#asset: Asset,
        pub r#size: u32,
    }
}

impl Packet for AssetInitialize {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "AssetInitialize",
        id: 24,
        is_compressed: false,
        max_size: 2121,
        category: PacketCategory::SETUP,
    };
}

codec! {
    pub struct AssetPart {
        pub r#part: Option<Vec<u8>>,
    }
}

impl Packet for AssetPart {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "AssetPart",
        id: 25,
        is_compressed: true,
        max_size: 4096006,
        category: PacketCategory::SETUP,
    };
}

codec! {
    pub struct AssetFinalize {
    }
}

impl Packet for AssetFinalize {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "AssetFinalize",
        id: 26,
        is_compressed: false,
        max_size: 0,
        category: PacketCategory::SETUP,
    };
}

codec! {
    pub struct RemoveAssets {
        pub r#asset: Option<Vec<Asset>>,
    }
}

impl Packet for RemoveAssets {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "RemoveAssets",
        id: 27,
        is_compressed: false,
        max_size: 1677721600,
        category: PacketCategory::SETUP,
    };
}

codec! {
    pub struct RequestCommonAssetsRebuild {
    }
}

impl Packet for RequestCommonAssetsRebuild {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "RequestCommonAssetsRebuild",
        id: 28,
        is_compressed: false,
        max_size: 0,
        category: PacketCategory::SETUP,
    };
}

codec! {
    pub struct SetUpdateRate {
        pub r#updatesPerSecond: u32,
    }
}

impl Packet for SetUpdateRate {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "SetUpdateRate",
        id: 29,
        is_compressed: false,
        max_size: 4,
        category: PacketCategory::SETUP,
    };
}

codec! {
    pub struct SetTimeDilation {
        pub r#timeDilation: f32,
    }
}

impl Packet for SetTimeDilation {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "SetTimeDilation",
        id: 30,
        is_compressed: false,
        max_size: 4,
        category: PacketCategory::SETUP,
    };
}

codec! {
    pub struct UpdateFeatures {
        pub r#features: Option<Dictionary<ClientFeature, bool>>,
    }
}

impl Packet for UpdateFeatures {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "UpdateFeatures",
        id: 31,
        is_compressed: false,
        max_size: 8192006,
        category: PacketCategory::SETUP,
    };
}

codec! {
    pub enum ClientFeature {
        r#SplitVelocity,
        r#Mantling,
        r#SprintForce,
        r#CrouchSlide,
        r#SafetyRoll,
        r#DisplayHealthBars,
        r#DisplayCombatText,
        r#CanHideHelmet,
        r#CanHideCuirass,
        r#CanHideGauntlets,
        r#CanHidePants,
    }
}

codec! {
    pub struct ViewRadius {
        pub r#value: u32,
    }
}

impl Packet for ViewRadius {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "ViewRadius",
        id: 32,
        is_compressed: false,
        max_size: 4,
        category: PacketCategory::SETUP,
    };
}

codec! {
    pub struct PlayerOptions {
        pub r#skin: Option<PlayerSkin>,
    }
}

impl Packet for PlayerOptions {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "PlayerOptions",
        id: 33,
        is_compressed: false,
        max_size: 327680184,
        category: PacketCategory::SETUP,
    };
}

codec! {
    pub struct PlayerSkin {
        pub r#bodyCharacteristic: Option<String>,
        pub r#underwear: Option<String>,
        pub r#face: Option<String>,
        pub r#eyes: Option<String>,
        pub r#ears: Option<String>,
        pub r#mouth: Option<String>,
        pub r#facialHair: Option<String>,
        pub r#haircut: Option<String>,
        pub r#eyebrows: Option<String>,
        pub r#pants: Option<String>,
        pub r#overpants: Option<String>,
        pub r#undertop: Option<String>,
        pub r#overtop: Option<String>,
        pub r#shoes: Option<String>,
        pub r#headAccessory: Option<String>,
        pub r#faceAccessory: Option<String>,
        pub r#earAccessory: Option<String>,
        pub r#skinFeature: Option<String>,
        pub r#gloves: Option<String>,
        pub r#cape: Option<String>,
    }
}

codec! {
    pub struct ServerTags {
        pub r#tags: Option<Dictionary<String, u32>>,
    }
}

impl Packet for ServerTags {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "ServerTags",
        id: 34,
        is_compressed: false,
        max_size: 1677721600,
        category: PacketCategory::SETUP,
    };
}

codec! {
    pub struct UpdateBlockTypes {
        pub r#type: UpdateType,
        pub r#maxId: u32,
        pub r#blockTypes: Option<Dictionary<u32, BlockType>>,
        pub r#updateBlockTextures: bool,
        pub r#updateModelTextures: bool,
        pub r#updateModels: bool,
        pub r#updateMapGeometry: bool,
    }
}

impl Packet for UpdateBlockTypes {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "UpdateBlockTypes",
        id: 40,
        is_compressed: true,
        max_size: 1677721600,
        category: PacketCategory::ASSETS,
    };
}

codec! {
    pub enum UpdateType {
        r#Init,
        r#AddOrUpdate,
        r#Remove,
    }
}

codec! {
    pub struct BlockType {
        pub r#item: Option<String>,
        pub r#name: Option<String>,
        pub r#unknown: bool,
        pub r#drawType: DrawType,
        pub r#material: BlockMaterial,
        pub r#opacity: Opacity,
        pub r#shaderEffect: Option<Vec<ShaderType>>,
        pub r#hitbox: u32,
        pub r#interactionHitbox: u32,
        pub r#model: Option<String>,
        pub r#modelTexture: Option<Vec<ModelTexture>>,
        pub r#modelScale: f32,
        pub r#modelAnimation: Option<String>,
        pub r#looping: bool,
        pub r#maxSupportDistance: u32,
        pub r#blockSupportsRequiredFor: BlockSupportsRequiredForType,
        pub r#support: Option<Dictionary<BlockNeighbor, Vec<RequiredBlockFaceSupport>>>,
        pub r#supporting: Option<Dictionary<BlockNeighbor, Vec<BlockFaceSupport>>>,
        pub r#requiresAlphaBlending: bool,
        pub r#cubeTextures: Option<Vec<BlockTextures>>,
        pub r#cubeSideMaskTexture: Option<String>,
        pub r#cubeShadingMode: ShadingMode,
        pub r#randomRotation: RandomRotation,
        pub r#variantRotation: VariantRotation,
        pub r#rotationYawPlacementOffset: Rotation,
        pub r#blockSoundSetIndex: u32,
        pub r#ambientSoundEventIndex: u32,
        pub r#particles: Option<Vec<ModelParticle>>,
        pub r#blockParticleSetId: Option<String>,
        pub r#blockBreakingDecalId: Option<String>,
        pub r#particleColor: Option<Color>,
        pub r#light: Option<ColorLight>,
        pub r#tint: Option<Tint>,
        pub r#biomeTint: Option<Tint>,
        pub r#group: u32,
        pub r#transitionTexture: Option<String>,
        pub r#transitionToGroups: Option<Vec<u32>>,
        pub r#movementSettings: Option<BlockMovementSettings>,
        pub r#flags: Option<BlockFlags>,
        pub r#interactionHint: Option<String>,
        pub r#gathering: Option<BlockGathering>,
        pub r#placementSettings: Option<BlockPlacementSettings>,
        pub r#display: Option<ModelDisplay>,
        pub r#rail: Option<RailConfig>,
        pub r#ignoreSupportWhenPlaced: bool,
        pub r#interactions: Option<Dictionary<InteractionType, u32>>,
        pub r#states: Option<Dictionary<String, u32>>,
        pub r#transitionToTag: u32,
        pub r#tagIndexes: Option<Vec<u32>>,
        pub r#bench: Option<Bench>,
        pub r#connectedBlockRuleSet: Option<ConnectedBlockRuleSet>,
    }
}

codec! {
    pub enum DrawType {
        r#Empty,
        r#GizmoCube,
        r#Cube,
        r#Model,
        r#CubeWithModel,
    }
}

codec! {
    pub enum BlockMaterial {
        r#Empty,
        r#Solid,
    }
}

codec! {
    pub enum Opacity {
        r#Solid,
        r#Semitransparent,
        r#Cutout,
        r#Transparent,
    }
}

codec! {
    pub enum ShaderType {
        r#None,
        r#Wind,
        r#WindAttached,
        r#WindRandom,
        r#WindFractal,
        r#Ice,
        r#Water,
        r#Lava,
        r#Slime,
        r#Ripple,
    }
}

codec! {
    pub struct ModelTexture {
        pub r#texture: Option<String>,
        pub r#weight: f32,
    }
}

codec! {
    pub enum BlockSupportsRequiredForType {
        r#Any,
        r#All,
    }
}

codec! {
    pub enum BlockNeighbor {
        r#Up,
        r#Down,
        r#North,
        r#East,
        r#South,
        r#West,
        r#UpNorth,
        r#UpSouth,
        r#UpEast,
        r#UpWest,
        r#DownNorth,
        r#DownSouth,
        r#DownEast,
        r#DownWest,
        r#NorthEast,
        r#SouthEast,
        r#SouthWest,
        r#NorthWest,
        r#UpNorthEast,
        r#UpSouthEast,
        r#UpSouthWest,
        r#UpNorthWest,
        r#DownNorthEast,
        r#DownSouthEast,
        r#DownSouthWest,
        r#DownNorthWest,
    }
}

codec! {
    pub struct RequiredBlockFaceSupport {
        pub r#faceType: Option<String>,
        pub r#selfFaceType: Option<String>,
        pub r#blockSetId: Option<String>,
        pub r#blockTypeId: u32,
        pub r#tagIndex: u32,
        pub r#fluidId: u32,
        pub r#support: SupportMatch,
        pub r#matchSelf: SupportMatch,
        pub r#allowSupportPropagation: bool,
        pub r#rotate: bool,
        pub r#filler: Option<Vec<Vector3i>>,
    }
}

codec! {
    pub enum SupportMatch {
        r#Ignored,
        r#Required,
        r#Disallowed,
    }
}

codec! {
    pub struct Vector3i {
        @small = true;
        pub r#x: u32,
        pub r#y: u32,
        pub r#z: u32,
    }
}

codec! {
    pub struct BlockFaceSupport {
        pub r#faceType: Option<String>,
        pub r#filler: Option<Vec<Vector3i>>,
    }
}

codec! {
    pub struct BlockTextures {
        pub r#top: Option<String>,
        pub r#bottom: Option<String>,
        pub r#front: Option<String>,
        pub r#back: Option<String>,
        pub r#left: Option<String>,
        pub r#right: Option<String>,
        pub r#weight: f32,
    }
}

codec! {
    pub enum ShadingMode {
        r#Standard,
        r#Flat,
        r#Fullbright,
        r#Reflective,
    }
}

codec! {
    pub enum RandomRotation {
        r#None,
        r#YawPitchRollStep1,
        r#YawStep1,
        r#YawStep1XZ,
        r#YawStep90,
    }
}

codec! {
    pub enum VariantRotation {
        r#None,
        r#Wall,
        r#UpDown,
        r#Pipe,
        r#DoublePipe,
        r#NESW,
        r#UpDownNESW,
        r#All,
    }
}

codec! {
    pub enum Rotation {
        r#None,
        r#Ninety,
        r#OneEighty,
        r#TwoSeventy,
    }
}

codec! {
    pub struct ModelParticle {
        pub r#systemId: Option<String>,
        pub r#scale: f32,
        pub r#color: Option<Color>,
        pub r#targetEntityPart: EntityPart,
        pub r#targetNodeName: Option<String>,
        pub r#positionOffset: Option<Vector3f>,
        pub r#rotationOffset: Option<Direction>,
        pub r#detachedFromModel: bool,
    }
}

codec! {
    pub struct Color {
        @small = true;
        pub r#red: u8,
        pub r#green: u8,
        pub r#blue: u8,
    }
}

codec! {
    pub enum EntityPart {
        Self_,
        r#Entity,
        r#PrimaryItem,
        r#SecondaryItem,
    }
}

codec! {
    pub struct Vector3f {
        @small = true;
        pub r#x: f32,
        pub r#y: f32,
        pub r#z: f32,
    }
}

codec! {
    pub struct Direction {
        @small = true;
        pub r#yaw: f32,
        pub r#pitch: f32,
        pub r#roll: f32,
    }
}

codec! {
    pub struct ColorLight {
        @small = true;
        pub r#radius: u8,
        pub r#red: u8,
        pub r#green: u8,
        pub r#blue: u8,
    }
}

codec! {
    pub struct Tint {
        @small = true;
        pub r#top: u32,
        pub r#bottom: u32,
        pub r#front: u32,
        pub r#back: u32,
        pub r#left: u32,
        pub r#right: u32,
    }
}

codec! {
    pub struct BlockMovementSettings {
        @small = true;
        pub r#isClimbable: bool,
        pub r#climbUpSpeedMultiplier: f32,
        pub r#climbDownSpeedMultiplier: f32,
        pub r#climbLateralSpeedMultiplier: f32,
        pub r#isBouncy: bool,
        pub r#bounceVelocity: f32,
        pub r#drag: f32,
        pub r#friction: f32,
        pub r#terminalVelocityModifier: f32,
        pub r#horizontalSpeedMultiplier: f32,
        pub r#acceleration: f32,
        pub r#jumpForceMultiplier: f32,
    }
}

codec! {
    pub struct BlockFlags {
        @small = true;
        pub r#isUsable: bool,
        pub r#isStackable: bool,
    }
}

codec! {
    pub struct BlockGathering {
        pub r#breaking: Option<BlockBreaking>,
        pub r#harvest: Option<Harvesting>,
        pub r#soft: Option<SoftBlock>,
    }
}

codec! {
    pub struct BlockBreaking {
        pub r#gatherType: Option<String>,
        pub r#health: f32,
        pub r#quantity: u32,
        pub r#quality: u32,
        pub r#itemId: Option<String>,
        pub r#dropListId: Option<String>,
    }
}

codec! {
    pub struct Harvesting {
        pub r#itemId: Option<String>,
        pub r#dropListId: Option<String>,
    }
}

codec! {
    pub struct SoftBlock {
        pub r#itemId: Option<String>,
        pub r#dropListId: Option<String>,
        pub r#isWeaponBreakable: bool,
    }
}

codec! {
    pub struct BlockPlacementSettings {
        @small = true;
        pub r#allowRotationKey: bool,
        pub r#placeInEmptyBlocks: bool,
        pub r#previewVisibility: BlockPreviewVisibility,
        pub r#rotationMode: BlockPlacementRotationMode,
        pub r#wallPlacementOverrideBlockId: u32,
        pub r#floorPlacementOverrideBlockId: u32,
        pub r#ceilingPlacementOverrideBlockId: u32,
    }
}

codec! {
    pub enum BlockPreviewVisibility {
        r#AlwaysVisible,
        r#AlwaysHidden,
        r#Default,
    }
}

codec! {
    pub enum BlockPlacementRotationMode {
        r#FacingPlayer,
        r#StairFacingPlayer,
        r#BlockNormal,
        r#Default,
    }
}

codec! {
    pub struct ModelDisplay {
        pub r#node: Option<String>,
        pub r#attachTo: Option<String>,
        pub r#translation: Option<Vector3f>,
        pub r#rotation: Option<Vector3f>,
        pub r#scale: Option<Vector3f>,
    }
}

codec! {
    pub struct RailConfig {
        pub r#points: Option<Vec<RailPoint>>,
    }
}

codec! {
    pub struct RailPoint {
        pub r#point: Option<Vector3f>,
        pub r#normal: Option<Vector3f>,
    }
}

codec! {
    pub enum InteractionType {
        r#Primary,
        r#Secondary,
        r#Ability1,
        r#Ability2,
        r#Ability3,
        r#Use,
        r#Pick,
        r#Pickup,
        r#CollisionEnter,
        r#CollisionLeave,
        r#Collision,
        r#EntityStatEffect,
        r#SwapTo,
        r#SwapFrom,
        r#Death,
        r#Wielding,
        r#ProjectileSpawn,
        r#ProjectileHit,
        r#ProjectileMiss,
        r#ProjectileBounce,
        r#Held,
        r#HeldOffhand,
        r#Equipped,
        r#Dodge,
        r#GameModeSwap,
    }
}

codec! {
    pub struct Bench {
        pub r#benchTierLevels: Option<Vec<BenchTierLevel>>,
    }
}

codec! {
    pub struct BenchTierLevel {
        pub r#benchUpgradeRequirement: Option<BenchUpgradeRequirement>,
        pub r#craftingTimeReductionModifier: f64,
        pub r#extraInputSlot: u32,
        pub r#extraOutputSlot: u32,
    }
}

codec! {
    pub struct BenchUpgradeRequirement {
        pub r#material: Option<Vec<MaterialQuantity>>,
        pub r#timeSeconds: f64,
    }
}

codec! {
    pub struct MaterialQuantity {
        pub r#itemId: Option<String>,
        pub r#itemTag: u32,
        pub r#resourceTypeId: Option<String>,
        pub r#quantity: u32,
    }
}

codec! {
    pub struct ConnectedBlockRuleSet {
        pub r#type: ConnectedBlockRuleSetType,
        pub r#stair: Option<StairConnectedBlockRuleSet>,
        pub r#roof: Option<RoofConnectedBlockRuleSet>,
    }
}

codec! {
    pub enum ConnectedBlockRuleSetType {
        r#Stair,
        r#Roof,
    }
}

codec! {
    pub struct StairConnectedBlockRuleSet {
        pub r#straightBlockId: u32,
        pub r#cornerLeftBlockId: u32,
        pub r#cornerRightBlockId: u32,
        pub r#invertedCornerLeftBlockId: u32,
        pub r#invertedCornerRightBlockId: u32,
        pub r#materialName: Option<String>,
    }
}

codec! {
    pub struct RoofConnectedBlockRuleSet {
        pub r#regular: Option<StairConnectedBlockRuleSet>,
        pub r#hollow: Option<StairConnectedBlockRuleSet>,
        pub r#topperBlockId: u32,
        pub r#width: u32,
        pub r#materialName: Option<String>,
    }
}

codec! {
    pub struct UpdateBlockHitboxes {
        pub r#type: UpdateType,
        pub r#maxId: u32,
        pub r#blockBaseHitboxes: Option<Dictionary<u32, Vec<Hitbox>>>,
    }
}

impl Packet for UpdateBlockHitboxes {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "UpdateBlockHitboxes",
        id: 41,
        is_compressed: true,
        max_size: 1677721600,
        category: PacketCategory::ASSETS,
    };
}

codec! {
    pub struct Hitbox {
        @small = true;
        pub r#minX: f32,
        pub r#minY: f32,
        pub r#minZ: f32,
        pub r#maxX: f32,
        pub r#maxY: f32,
        pub r#maxZ: f32,
    }
}

codec! {
    pub struct UpdateBlockSoundSets {
        pub r#type: UpdateType,
        pub r#maxId: u32,
        pub r#blockSoundSets: Option<Dictionary<u32, BlockSoundSet>>,
    }
}

impl Packet for UpdateBlockSoundSets {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "UpdateBlockSoundSets",
        id: 42,
        is_compressed: true,
        max_size: 1677721600,
        category: PacketCategory::ASSETS,
    };
}

codec! {
    pub struct BlockSoundSet {
        pub r#id: Option<String>,
        pub r#soundEventIndices: Option<Dictionary<BlockSoundEvent, u32>>,
        pub r#moveInRepeatRange: Option<FloatRange>,
    }
}

codec! {
    pub enum BlockSoundEvent {
        r#Walk,
        r#Land,
        r#MoveIn,
        r#MoveOut,
        r#Hit,
        r#Break,
        r#Build,
        r#Clone,
        r#Harvest,
    }
}

codec! {
    pub struct FloatRange {
        @small = true;
        pub r#inclusiveMin: f32,
        pub r#inclusiveMax: f32,
    }
}

codec! {
    pub struct UpdateItemSoundSets {
        pub r#type: UpdateType,
        pub r#maxId: u32,
        pub r#itemSoundSets: Option<Dictionary<u32, ItemSoundSet>>,
    }
}

impl Packet for UpdateItemSoundSets {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "UpdateItemSoundSets",
        id: 43,
        is_compressed: true,
        max_size: 1677721600,
        category: PacketCategory::ASSETS,
    };
}

codec! {
    pub struct ItemSoundSet {
        pub r#id: Option<String>,
        pub r#soundEventIndices: Option<Dictionary<ItemSoundEvent, u32>>,
    }
}

codec! {
    pub enum ItemSoundEvent {
        r#Drag,
        r#Drop,
    }
}

codec! {
    pub struct UpdateBlockParticleSets {
        pub r#type: UpdateType,
        pub r#blockParticleSets: Option<Dictionary<String, BlockParticleSet>>,
    }
}

impl Packet for UpdateBlockParticleSets {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "UpdateBlockParticleSets",
        id: 44,
        is_compressed: true,
        max_size: 1677721600,
        category: PacketCategory::ASSETS,
    };
}

codec! {
    pub struct BlockParticleSet {
        pub r#id: Option<String>,
        pub r#color: Option<Color>,
        pub r#scale: f32,
        pub r#positionOffset: Option<Vector3f>,
        pub r#rotationOffset: Option<Direction>,
        pub r#particleSystemIds: Option<Dictionary<BlockParticleEvent, String>>,
    }
}

codec! {
    pub enum BlockParticleEvent {
        r#Walk,
        r#Run,
        r#Sprint,
        r#SoftLand,
        r#HardLand,
        r#MoveOut,
        r#Hit,
        r#Break,
        r#Build,
        r#Physics,
    }
}

codec! {
    pub struct UpdateBlockBreakingDecals {
        pub r#type: UpdateType,
        pub r#blockBreakingDecals: Option<Dictionary<String, BlockBreakingDecal>>,
    }
}

impl Packet for UpdateBlockBreakingDecals {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "UpdateBlockBreakingDecals",
        id: 45,
        is_compressed: true,
        max_size: 1677721600,
        category: PacketCategory::ASSETS,
    };
}

codec! {
    pub struct BlockBreakingDecal {
        pub r#stageTextures: Option<Vec<String>>,
    }
}

codec! {
    pub struct UpdateBlockSets {
        pub r#type: UpdateType,
        pub r#blockSets: Option<Dictionary<String, BlockSet>>,
    }
}

impl Packet for UpdateBlockSets {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "UpdateBlockSets",
        id: 46,
        is_compressed: true,
        max_size: 1677721600,
        category: PacketCategory::ASSETS,
    };
}

codec! {
    pub struct BlockSet {
        pub r#name: Option<String>,
        pub r#blocks: Option<Vec<u32>>,
    }
}

codec! {
    pub struct UpdateWeathers {
        pub r#type: UpdateType,
        pub r#maxId: u32,
        pub r#weathers: Option<Dictionary<u32, Weather>>,
    }
}

impl Packet for UpdateWeathers {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "UpdateWeathers",
        id: 47,
        is_compressed: true,
        max_size: 1677721600,
        category: PacketCategory::ASSETS,
    };
}

codec! {
    pub struct Weather {
        pub r#id: Option<String>,
        pub r#tagIndexes: Option<Vec<u32>>,
        pub r#stars: Option<String>,
        pub r#moons: Option<Dictionary<u32, String>>,
        pub r#clouds: Option<Vec<Cloud>>,
        pub r#sunlightDampingMultiplier: Option<Dictionary<f32, f32>>,
        pub r#sunlightColors: Option<Dictionary<f32, Color>>,
        pub r#skyTopColors: Option<Dictionary<f32, ColorAlpha>>,
        pub r#skyBottomColors: Option<Dictionary<f32, ColorAlpha>>,
        pub r#skySunsetColors: Option<Dictionary<f32, ColorAlpha>>,
        pub r#sunColors: Option<Dictionary<f32, Color>>,
        pub r#sunScales: Option<Dictionary<f32, f32>>,
        pub r#sunGlowColors: Option<Dictionary<f32, ColorAlpha>>,
        pub r#moonColors: Option<Dictionary<f32, ColorAlpha>>,
        pub r#moonScales: Option<Dictionary<f32, f32>>,
        pub r#moonGlowColors: Option<Dictionary<f32, ColorAlpha>>,
        pub r#fogColors: Option<Dictionary<f32, Color>>,
        pub r#fogHeightFalloffs: Option<Dictionary<f32, f32>>,
        pub r#fogDensities: Option<Dictionary<f32, f32>>,
        pub r#screenEffect: Option<String>,
        pub r#screenEffectColors: Option<Dictionary<f32, ColorAlpha>>,
        pub r#colorFilters: Option<Dictionary<f32, Color>>,
        pub r#waterTints: Option<Dictionary<f32, Color>>,
        pub r#particle: Option<WeatherParticle>,
        pub r#fog: Option<NearFar>,
        pub r#fogOptions: Option<FogOptions>,
    }
}

codec! {
    pub struct Cloud {
        pub r#texture: Option<String>,
        pub r#speeds: Option<Dictionary<f32, f32>>,
        pub r#colors: Option<Dictionary<f32, ColorAlpha>>,
    }
}

codec! {
    pub struct ColorAlpha {
        @small = true;
        pub r#alpha: u8,
        pub r#red: u8,
        pub r#green: u8,
        pub r#blue: u8,
    }
}

codec! {
    pub struct WeatherParticle {
        pub r#systemId: Option<String>,
        pub r#color: Option<Color>,
        pub r#scale: f32,
        pub r#isOvergroundOnly: bool,
        pub r#positionOffsetMultiplier: f32,
    }
}

codec! {
    pub struct NearFar {
        @small = true;
        pub r#near: f32,
        pub r#far: f32,
    }
}

codec! {
    pub struct FogOptions {
        @small = true;
        pub r#ignoreFogLimits: bool,
        pub r#effectiveViewDistanceMultiplier: f32,
        pub r#fogFarViewDistance: f32,
        pub r#fogHeightCameraOffset: f32,
        pub r#fogHeightCameraOverriden: bool,
        pub r#fogHeightCameraFixed: f32,
    }
}

codec! {
    pub struct UpdateTrails {
        pub r#type: UpdateType,
        pub r#trails: Option<Dictionary<String, Trail>>,
    }
}

impl Packet for UpdateTrails {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "UpdateTrails",
        id: 48,
        is_compressed: true,
        max_size: 1677721600,
        category: PacketCategory::ASSETS,
    };
}

codec! {
    pub struct Trail {
        pub r#id: Option<String>,
        pub r#texture: Option<String>,
        pub r#lifeSpan: u32,
        pub r#roll: f32,
        pub r#start: Option<Edge>,
        pub r#end: Option<Edge>,
        pub r#lightInfluence: f32,
        pub r#renderMode: FXRenderMode,
        pub r#intersectionHighlight: Option<IntersectionHighlight>,
        pub r#smooth: bool,
        pub r#frameSize: Option<Vector2i>,
        pub r#frameRange: Option<Range>,
        pub r#frameLifeSpan: u32,
    }
}

codec! {
    pub struct Edge {
        @small = true;
        pub r#color: Option<ColorAlpha>,
        pub r#width: f32,
    }
}

codec! {
    pub enum FXRenderMode {
        r#BlendLinear,
        r#BlendAdd,
        r#Erosion,
        r#Distortion,
    }
}

codec! {
    pub struct IntersectionHighlight {
        @small = true;
        pub r#highlightThreshold: f32,
        pub r#highlightColor: Option<Color>,
    }
}

codec! {
    pub struct Vector2i {
        @small = true;
        pub r#x: u32,
        pub r#y: u32,
    }
}

codec! {
    pub struct Range {
        @small = true;
        pub r#min: u32,
        pub r#max: u32,
    }
}

codec! {
    pub struct UpdateParticleSystems {
        pub r#type: UpdateType,
        pub r#particleSystems: Option<Dictionary<String, ParticleSystem>>,
        pub r#removedParticleSystems: Option<Vec<String>>,
    }
}

impl Packet for UpdateParticleSystems {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "UpdateParticleSystems",
        id: 49,
        is_compressed: true,
        max_size: 1677721600,
        category: PacketCategory::ASSETS,
    };
}

codec! {
    pub struct ParticleSystem {
        pub r#id: Option<String>,
        pub r#spawners: Option<Vec<ParticleSpawnerGroup>>,
        pub r#lifeSpan: f32,
        pub r#cullDistance: f32,
        pub r#boundingRadius: f32,
        pub r#isImportant: bool,
    }
}

codec! {
    pub struct ParticleSpawnerGroup {
        pub r#spawnerId: Option<String>,
        pub r#positionOffset: Option<Vector3f>,
        pub r#rotationOffset: Option<Direction>,
        pub r#fixedRotation: bool,
        pub r#startDelay: f32,
        pub r#spawnRate: Option<Rangef>,
        pub r#waveDelay: Option<Rangef>,
        pub r#totalSpawners: u32,
        pub r#maxConcurrent: u32,
        pub r#initialVelocity: Option<InitialVelocity>,
        pub r#emitOffset: Option<RangeVector3f>,
        pub r#lifeSpan: Option<Rangef>,
        pub r#attractors: Option<Vec<ParticleAttractor>>,
    }
}

codec! {
    pub struct Rangef {
        @small = true;
        pub r#min: f32,
        pub r#max: f32,
    }
}

codec! {
    pub struct InitialVelocity {
        @small = true;
        pub r#yaw: Option<Rangef>,
        pub r#pitch: Option<Rangef>,
        pub r#speed: Option<Rangef>,
    }
}

codec! {
    pub struct RangeVector3f {
        @small = true;
        pub r#x: Option<Rangef>,
        pub r#y: Option<Rangef>,
        pub r#z: Option<Rangef>,
    }
}

codec! {
    pub struct ParticleAttractor {
        pub r#position: Option<Vector3f>,
        pub r#radialAxis: Option<Vector3f>,
        pub r#trailPositionMultiplier: f32,
        pub r#radius: f32,
        pub r#radialAcceleration: f32,
        pub r#radialTangentAcceleration: f32,
        pub r#linearAcceleration: Option<Vector3f>,
        pub r#radialImpulse: f32,
        pub r#radialTangentImpulse: f32,
        pub r#linearImpulse: Option<Vector3f>,
        pub r#dampingMultiplier: Option<Vector3f>,
    }
}

codec! {
    pub struct UpdateParticleSpawners {
        pub r#type: UpdateType,
        pub r#particleSpawners: Option<Dictionary<String, ParticleSpawner>>,
        pub r#removedParticleSpawners: Option<Vec<String>>,
    }
}

impl Packet for UpdateParticleSpawners {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "UpdateParticleSpawners",
        id: 50,
        is_compressed: true,
        max_size: 1677721600,
        category: PacketCategory::ASSETS,
    };
}

codec! {
    pub struct ParticleSpawner {
        pub r#id: Option<String>,
        pub r#particle: Option<Particle>,
        pub r#shape: EmitShape,
        pub r#emitOffset: Option<RangeVector3f>,
        pub r#cameraOffset: f32,
        pub r#useEmitDirection: bool,
        pub r#lifeSpan: f32,
        pub r#spawnRate: Option<Rangef>,
        pub r#spawnBurst: bool,
        pub r#waveDelay: Option<Rangef>,
        pub r#totalParticles: Option<Range>,
        pub r#maxConcurrentParticles: u32,
        pub r#initialVelocity: Option<InitialVelocity>,
        pub r#velocityStretchMultiplier: f32,
        pub r#particleRotationInfluence: ParticleRotationInfluence,
        pub r#particleRotateWithSpawner: bool,
        pub r#isLowRes: bool,
        pub r#trailSpawnerPositionMultiplier: f32,
        pub r#trailSpawnerRotationMultiplier: f32,
        pub r#particleCollision: Option<ParticleCollision>,
        pub r#renderMode: FXRenderMode,
        pub r#lightInfluence: f32,
        pub r#linearFiltering: bool,
        pub r#particleLifeSpan: Option<Rangef>,
        pub r#uvMotion: Option<UVMotion>,
        pub r#attractors: Option<Vec<ParticleAttractor>>,
        pub r#intersectionHighlight: Option<IntersectionHighlight>,
    }
}

codec! {
    pub struct Particle {
        pub r#texturePath: Option<String>,
        pub r#frameSize: Option<Size>,
        pub r#uvOption: ParticleUVOption,
        pub r#scaleRatioConstraint: ParticleScaleRatioConstraint,
        pub r#softParticles: SoftParticle,
        pub r#softParticlesFadeFactor: f32,
        pub r#useSpriteBlending: bool,
        pub r#initialAnimationFrame: Option<ParticleAnimationFrame>,
        pub r#collisionAnimationFrame: Option<ParticleAnimationFrame>,
        pub r#animationFrames: Option<Dictionary<u32, ParticleAnimationFrame>>,
    }
}

codec! {
    pub struct Size {
        @small = true;
        pub r#width: u32,
        pub r#height: u32,
    }
}

codec! {
    pub enum ParticleUVOption {
        r#None,
        r#RandomFlipU,
        r#RandomFlipV,
        r#RandomFlipUV,
        r#FlipU,
        r#FlipV,
        r#FlipUV,
    }
}

codec! {
    pub enum ParticleScaleRatioConstraint {
        r#OneToOne,
        r#Preserved,
        r#None,
    }
}

codec! {
    pub enum SoftParticle {
        r#Enable,
        r#Disable,
        r#Require,
    }
}

codec! {
    pub struct ParticleAnimationFrame {
        @small = true;
        pub r#frameIndex: Option<Range>,
        pub r#scale: Option<RangeVector2f>,
        pub r#rotation: Option<RangeVector3f>,
        pub r#color: Option<Color>,
        pub r#opacity: f32,
    }
}

codec! {
    pub struct RangeVector2f {
        @small = true;
        pub r#x: Option<Rangef>,
        pub r#y: Option<Rangef>,
    }
}

codec! {
    pub enum EmitShape {
        r#Sphere,
        r#Cube,
    }
}

codec! {
    pub enum ParticleRotationInfluence {
        r#None,
        r#Billboard,
        r#BillboardY,
        r#BillboardVelocity,
        r#Velocity,
    }
}

codec! {
    pub struct ParticleCollision {
        @small = true;
        pub r#blockType: ParticleCollisionBlockType,
        pub r#action: ParticleCollisionAction,
        pub r#particleRotationInfluence: ParticleRotationInfluence,
    }
}

codec! {
    pub enum ParticleCollisionBlockType {
        r#None,
        r#Air,
        r#Solid,
        r#All,
    }
}

codec! {
    pub enum ParticleCollisionAction {
        r#Expire,
        r#LastFrame,
        r#Linger,
    }
}

codec! {
    pub struct UVMotion {
        pub r#texture: Option<String>,
        pub r#addRandomUVOffset: bool,
        pub r#speedX: f32,
        pub r#speedY: f32,
        pub r#scale: f32,
        pub r#strength: f32,
        pub r#strengthCurveType: UVMotionCurveType,
    }
}

codec! {
    pub enum UVMotionCurveType {
        r#Constant,
        r#IncreaseLinear,
        r#IncreaseQuartIn,
        r#IncreaseQuartInOut,
        r#IncreaseQuartOut,
        r#DecreaseLinear,
        r#DecreaseQuartIn,
        r#DecreaseQuartInOut,
        r#DecreaseQuartOut,
    }
}

codec! {
    pub struct UpdateEntityEffects {
        pub r#type: UpdateType,
        pub r#maxId: u32,
        pub r#entityEffects: Option<Dictionary<u32, EntityEffect>>,
    }
}

impl Packet for UpdateEntityEffects {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "UpdateEntityEffects",
        id: 51,
        is_compressed: true,
        max_size: 1677721600,
        category: PacketCategory::ASSETS,
    };
}

codec! {
    pub struct EntityEffect {
        pub r#id: Option<String>,
        pub r#name: Option<String>,
        pub r#applicationEffects: Option<ApplicationEffects>,
        pub r#worldRemovalSoundEventIndex: u32,
        pub r#localRemovalSoundEventIndex: u32,
        pub r#modelOverride: Option<ModelOverride>,
        pub r#duration: f32,
        pub r#infinite: bool,
        pub r#debuff: bool,
        pub r#statusEffectIcon: Option<String>,
        pub r#overlapBehavior: OverlapBehavior,
        pub r#damageCalculatorCooldown: f64,
        pub r#statModifiers: Option<Dictionary<u32, f32>>,
        pub r#valueType: ValueType,
    }
}

codec! {
    pub struct ApplicationEffects {
        pub r#entityBottomTint: Option<Color>,
        pub r#entityTopTint: Option<Color>,
        pub r#entityAnimationId: Option<String>,
        pub r#particles: Option<Vec<ModelParticle>>,
        pub r#firstPersonParticles: Option<Vec<ModelParticle>>,
        pub r#screenEffect: Option<String>,
        pub r#horizontalSpeedMultiplier: f32,
        pub r#soundEventIndexLocal: u32,
        pub r#soundEventIndexWorld: u32,
        pub r#modelVFXId: Option<String>,
        pub r#movementEffects: Option<MovementEffects>,
        pub r#mouseSensitivityAdjustmentTarget: f32,
        pub r#mouseSensitivityAdjustmentDuration: f32,
        pub r#abilityEffects: Option<AbilityEffects>,
    }
}

codec! {
    pub struct MovementEffects {
        @small = true;
        pub r#disableForward: bool,
        pub r#disableBackward: bool,
        pub r#disableLeft: bool,
        pub r#disableRight: bool,
        pub r#disableSprint: bool,
        pub r#disableJump: bool,
        pub r#disableCrouch: bool,
    }
}

codec! {
    pub struct AbilityEffects {
        pub r#disabled: Option<Vec<InteractionType>>,
    }
}

codec! {
    pub struct ModelOverride {
        pub r#model: Option<String>,
        pub r#texture: Option<String>,
        pub r#animationSets: Option<Dictionary<String, AnimationSet>>,
    }
}

codec! {
    pub struct AnimationSet {
        pub r#id: Option<String>,
        pub r#animations: Option<Vec<Animation>>,
        pub r#nextAnimationDelay: Option<Rangef>,
    }
}

codec! {
    pub struct Animation {
        pub r#name: Option<String>,
        pub r#speed: f32,
        pub r#blendingDuration: f32,
        pub r#looping: bool,
        pub r#weight: f32,
        pub r#footstepIntervals: Option<Vec<u32>>,
        pub r#soundEventIndex: u32,
        pub r#passiveLoopCount: u32,
    }
}

codec! {
    pub enum OverlapBehavior {
        r#Extend,
        r#Overwrite,
        r#Ignore,
    }
}

codec! {
    pub enum ValueType {
        r#Percent,
        r#Absolute,
    }
}

codec! {
    pub struct UpdateItemPlayerAnimations {
        pub r#type: UpdateType,
        pub r#itemPlayerAnimations: Option<Dictionary<String, ItemPlayerAnimations>>,
    }
}

impl Packet for UpdateItemPlayerAnimations {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "UpdateItemPlayerAnimations",
        id: 52,
        is_compressed: true,
        max_size: 1677721600,
        category: PacketCategory::ASSETS,
    };
}

codec! {
    pub struct ItemPlayerAnimations {
        pub r#id: Option<String>,
        pub r#animations: Option<Dictionary<String, ItemAnimation>>,
        pub r#wiggleWeights: Option<WiggleWeights>,
        pub r#camera: Option<CameraSettings>,
        pub r#pullbackConfig: Option<ItemPullbackConfiguration>,
        pub r#useFirstPersonOverride: bool,
    }
}

codec! {
    pub struct ItemAnimation {
        pub r#thirdPerson: Option<String>,
        pub r#thirdPersonMoving: Option<String>,
        pub r#thirdPersonFace: Option<String>,
        pub r#firstPerson: Option<String>,
        pub r#firstPersonOverride: Option<String>,
        pub r#keepPreviousFirstPersonAnimation: bool,
        pub r#speed: f32,
        pub r#blendingDuration: f32,
        pub r#looping: bool,
        pub r#clipsGeometry: bool,
    }
}

codec! {
    pub struct WiggleWeights {
        @small = true;
        pub r#x: f32,
        pub r#xDeceleration: f32,
        pub r#y: f32,
        pub r#yDeceleration: f32,
        pub r#z: f32,
        pub r#zDeceleration: f32,
        pub r#roll: f32,
        pub r#rollDeceleration: f32,
        pub r#pitch: f32,
        pub r#pitchDeceleration: f32,
    }
}

codec! {
    pub struct CameraSettings {
        pub r#positionOffset: Option<Vector3f>,
        pub r#yaw: Option<CameraAxis>,
        pub r#pitch: Option<CameraAxis>,
    }
}

codec! {
    pub struct CameraAxis {
        pub r#angleRange: Option<Rangef>,
        pub r#targetNodes: Option<Vec<CameraNode>>,
    }
}

codec! {
    pub enum CameraNode {
        r#None,
        r#Head,
        r#LShoulder,
        r#RShoulder,
        r#Belly,
    }
}

codec! {
    pub struct ItemPullbackConfiguration {
        @small = true;
        pub r#leftOffsetOverride: Option<Vector3f>,
        pub r#leftRotationOverride: Option<Vector3f>,
        pub r#rightOffsetOverride: Option<Vector3f>,
        pub r#rightRotationOverride: Option<Vector3f>,
    }
}

codec! {
    pub struct UpdateModelvfxs {
        pub r#type: UpdateType,
        pub r#maxId: u32,
        pub r#modelVFXs: Option<Dictionary<u32, ModelVFX>>,
    }
}

impl Packet for UpdateModelvfxs {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "UpdateModelvfxs",
        id: 53,
        is_compressed: true,
        max_size: 1677721600,
        category: PacketCategory::ASSETS,
    };
}

codec! {
    pub struct ModelVFX {
        pub r#id: Option<String>,
        pub r#switchTo: SwitchTo,
        pub r#effectDirection: EffectDirection,
        pub r#animationDuration: f32,
        pub r#animationRange: Option<Vector2f>,
        pub r#loopOption: LoopOption,
        pub r#curveType: CurveType,
        pub r#highlightColor: Option<Color>,
        pub r#highlightThickness: f32,
        pub r#useBloomOnHighlight: bool,
        pub r#useProgessiveHighlight: bool,
        pub r#noiseScale: Option<Vector2f>,
        pub r#noiseScrollSpeed: Option<Vector2f>,
        pub r#postColor: Option<Color>,
        pub r#postColorOpacity: f32,
    }
}

codec! {
    pub enum SwitchTo {
        r#Disappear,
        r#PostColor,
        r#Distortion,
        r#Transparency,
    }
}

codec! {
    pub enum EffectDirection {
        r#None,
        r#BottomUp,
        r#TopDown,
        r#ToCenter,
        r#FromCenter,
    }
}

codec! {
    pub struct Vector2f {
        @small = true;
        pub r#x: f32,
        pub r#y: f32,
    }
}

codec! {
    pub enum LoopOption {
        r#PlayOnce,
        r#Loop,
        r#LoopMirror,
    }
}

codec! {
    pub enum CurveType {
        r#Linear,
        r#QuartIn,
        r#QuartOut,
        r#QuartInOut,
    }
}

codec! {
    pub struct UpdateItems {
        pub r#type: UpdateType,
        pub r#items: Option<Dictionary<String, ItemBase>>,
        pub r#removedItems: Option<Vec<String>>,
        pub r#updateModels: bool,
        pub r#updateIcons: bool,
    }
}

impl Packet for UpdateItems {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "UpdateItems",
        id: 54,
        is_compressed: true,
        max_size: 1677721600,
        category: PacketCategory::ASSETS,
    };
}

codec! {
    pub struct ItemBase {
        pub r#id: Option<String>,
        pub r#model: Option<String>,
        pub r#scale: f32,
        pub r#texture: Option<String>,
        pub r#animation: Option<String>,
        pub r#playerAnimationsId: Option<String>,
        pub r#usePlayerAnimations: bool,
        pub r#maxStack: u32,
        pub r#reticleIndex: u32,
        pub r#icon: Option<String>,
        pub r#iconProperties: Option<AssetIconProperties>,
        pub r#translationProperties: Option<ItemTranslationProperties>,
        pub r#itemLevel: u32,
        pub r#qualityIndex: u32,
        pub r#resourceTypes: Option<Vec<ItemResourceType>>,
        pub r#consumable: bool,
        pub r#variant: bool,
        pub r#blockId: u32,
        pub r#tool: Option<ItemTool>,
        pub r#weapon: Option<ItemWeapon>,
        pub r#armor: Option<ItemArmor>,
        pub r#gliderConfig: Option<ItemGlider>,
        pub r#utility: Option<ItemUtility>,
        pub r#blockSelectorTool: Option<BlockSelectorToolData>,
        pub r#builderToolData: Option<ItemBuilderToolData>,
        pub r#itemEntity: Option<ItemEntityConfig>,
        pub r#set: Option<String>,
        pub r#categories: Option<Vec<String>>,
        pub r#particles: Option<Vec<ModelParticle>>,
        pub r#firstPersonParticles: Option<Vec<ModelParticle>>,
        pub r#trails: Option<Vec<ModelTrail>>,
        pub r#light: Option<ColorLight>,
        pub r#durability: f64,
        pub r#soundEventIndex: u32,
        pub r#itemSoundSetIndex: u32,
        pub r#interactions: Option<Dictionary<InteractionType, u32>>,
        pub r#interactionVars: Option<Dictionary<String, u32>>,
        pub r#interactionConfig: Option<InteractionConfiguration>,
        pub r#droppedItemAnimation: Option<String>,
        pub r#tagIndexes: Option<Vec<u32>>,
        pub r#itemAppearanceConditions: Option<Dictionary<u32, Vec<ItemAppearanceCondition>>>,
        pub r#displayEntityStatsHUD: Option<Vec<u32>>,
        pub r#pullbackConfig: Option<ItemPullbackConfiguration>,
        pub r#clipsGeometry: bool,
        pub r#renderDeployablePreview: bool,
    }
}

codec! {
    pub struct AssetIconProperties {
        @small = true;
        pub r#scale: f32,
        pub r#translation: Option<Vector2f>,
        pub r#rotation: Option<Vector3f>,
    }
}

codec! {
    pub struct ItemTranslationProperties {
        pub r#name: Option<String>,
        pub r#description: Option<String>,
    }
}

codec! {
    pub struct ItemResourceType {
        pub r#id: Option<String>,
        pub r#quantity: u32,
    }
}

codec! {
    pub struct ItemTool {
        pub r#specs: Option<Vec<ItemToolSpec>>,
        pub r#speed: f32,
    }
}

codec! {
    pub struct ItemToolSpec {
        pub r#gatherType: Option<String>,
        pub r#power: f32,
        pub r#quality: u32,
    }
}

codec! {
    pub struct ItemWeapon {
        pub r#entityStatsToClear: Option<Vec<u32>>,
        pub r#statModifiers: Option<Dictionary<u32, Vec<Modifier>>>,
        pub r#renderDualWielded: bool,
    }
}

codec! {
    pub struct Modifier {
        pub r#target: ModifierTarget,
        pub r#calculationType: CalculationType,
        pub r#amount: f32,
    }
}

codec! {
    pub enum ModifierTarget {
        r#Min,
        r#Max,
    }
}

codec! {
    pub enum CalculationType {
        r#Additive,
        r#Multiplicative,
    }
}

codec! {
    pub struct ItemArmor {
        pub r#armorSlot: ItemArmorSlot,
        pub r#cosmeticsToHide: Option<Vec<Cosmetic>>,
        pub r#statModifiers: Option<Dictionary<u32, Vec<Modifier>>>,
        pub r#baseDamageResistance: f64,
        pub r#damageResistance: Option<Dictionary<String, Vec<Modifier>>>,
        pub r#damageEnhancement: Option<Dictionary<String, Vec<Modifier>>>,
        pub r#damageClassEnhancement: Option<Dictionary<String, Vec<Modifier>>>,
    }
}

codec! {
    pub enum ItemArmorSlot {
        r#Head,
        r#Chest,
        r#Hands,
        r#Legs,
    }
}

codec! {
    pub enum Cosmetic {
        r#Haircut,
        r#FacialHair,
        r#Undertop,
        r#Overtop,
        r#Pants,
        r#Overpants,
        r#Shoes,
        r#Gloves,
        r#Cape,
        r#HeadAccessory,
        r#FaceAccessory,
        r#EarAccessory,
        r#Ear,
    }
}

codec! {
    pub struct ItemGlider {
        @small = true;
        pub r#terminalVelocity: f32,
        pub r#fallSpeedMultiplier: f32,
        pub r#horizontalSpeedMultiplier: f32,
        pub r#speed: f32,
    }
}

codec! {
    pub struct ItemUtility {
        pub r#usable: bool,
        pub r#compatible: bool,
        pub r#entityStatsToClear: Option<Vec<u32>>,
        pub r#statModifiers: Option<Dictionary<u32, Vec<Modifier>>>,
    }
}

codec! {
    pub struct BlockSelectorToolData {
        @small = true;
        pub r#durabilityLossOnUse: f32,
    }
}

codec! {
    pub struct ItemBuilderToolData {
        pub r#ui: Option<Vec<String>>,
        pub r#tools: Option<Vec<BuilderToolState>>,
    }
}

codec! {
    pub struct BuilderToolState {
        pub r#id: Option<String>,
        pub r#isBrush: bool,
        pub r#brushData: Option<BuilderToolBrushData>,
        pub r#args: Option<Dictionary<String, BuilderToolArg>>,
    }
}

codec! {
    pub struct BuilderToolBrushData {
        pub r#width: Option<BuilderToolIntArg>,
        pub r#height: Option<BuilderToolIntArg>,
        pub r#thickness: Option<BuilderToolIntArg>,
        pub r#capped: Option<BuilderToolBoolArg>,
        pub r#shape: Option<BuilderToolBrushShapeArg>,
        pub r#origin: Option<BuilderToolBrushOriginArg>,
        pub r#originRotation: Option<BuilderToolBoolArg>,
        pub r#rotationAxis: Option<BuilderToolBrushAxisArg>,
        pub r#rotationAngle: Option<BuilderToolRotationArg>,
        pub r#mirrorAxis: Option<BuilderToolBrushAxisArg>,
        pub r#material: Option<BuilderToolBlockArg>,
        pub r#favoriteMaterials: Option<Vec<BuilderToolBlockArg>>,
        pub r#mask: Option<BuilderToolMaskArg>,
        pub r#maskAbove: Option<BuilderToolMaskArg>,
        pub r#maskNot: Option<BuilderToolMaskArg>,
        pub r#maskBelow: Option<BuilderToolMaskArg>,
        pub r#maskAdjacent: Option<BuilderToolMaskArg>,
        pub r#maskNeighbor: Option<BuilderToolMaskArg>,
        pub r#maskCommands: Option<Vec<BuilderToolStringArg>>,
        pub r#useMaskCommands: Option<BuilderToolBoolArg>,
        pub r#invertMask: Option<BuilderToolBoolArg>,
    }
}

codec! {
    pub struct BuilderToolIntArg {
        @small = true;
        pub r#defaultValue: u32,
        pub r#min: u32,
        pub r#max: u32,
    }
}

codec! {
    pub struct BuilderToolBoolArg {
        @small = true;
        pub r#defaultValue: bool,
    }
}

codec! {
    pub struct BuilderToolBrushShapeArg {
        @small = true;
        pub r#defaultValue: BrushShape,
    }
}

codec! {
    pub enum BrushShape {
        r#Cube,
        r#Sphere,
        r#Cylinder,
        r#Cone,
        r#InvertedCone,
        r#Pyramid,
        r#InvertedPyramid,
        r#Dome,
        r#InvertedDome,
        r#Diamond,
        r#Torus,
    }
}

codec! {
    pub struct BuilderToolBrushOriginArg {
        @small = true;
        pub r#defaultValue: BrushOrigin,
    }
}

codec! {
    pub enum BrushOrigin {
        r#Center,
        r#Bottom,
        r#Top,
    }
}

codec! {
    pub struct BuilderToolBrushAxisArg {
        @small = true;
        pub r#defaultValue: BrushAxis,
    }
}

codec! {
    pub enum BrushAxis {
        r#None,
        r#Auto,
        r#X,
        r#Y,
        r#Z,
    }
}

codec! {
    pub struct BuilderToolRotationArg {
        @small = true;
        pub r#defaultValue: Rotation,
    }
}

codec! {
    pub struct BuilderToolBlockArg {
        pub r#defaultValue: Option<String>,
        pub r#allowPattern: bool,
    }
}

codec! {
    pub struct BuilderToolMaskArg {
        pub r#defaultValue: Option<String>,
    }
}

codec! {
    pub struct BuilderToolStringArg {
        pub r#defaultValue: Option<String>,
    }
}

codec! {
    pub struct BuilderToolArg {
        pub r#required: bool,
        pub r#argType: BuilderToolArgType,
        pub r#boolArg: Option<BuilderToolBoolArg>,
        pub r#floatArg: Option<BuilderToolFloatArg>,
        pub r#intArg: Option<BuilderToolIntArg>,
        pub r#stringArg: Option<BuilderToolStringArg>,
        pub r#blockArg: Option<BuilderToolBlockArg>,
        pub r#maskArg: Option<BuilderToolMaskArg>,
        pub r#brushShapeArg: Option<BuilderToolBrushShapeArg>,
        pub r#brushOriginArg: Option<BuilderToolBrushOriginArg>,
        pub r#brushAxisArg: Option<BuilderToolBrushAxisArg>,
        pub r#rotationArg: Option<BuilderToolRotationArg>,
        pub r#optionArg: Option<BuilderToolOptionArg>,
    }
}

codec! {
    pub enum BuilderToolArgType {
        r#Bool,
        r#Float,
        r#Int,
        r#String,
        r#Block,
        r#Mask,
        r#BrushShape,
        r#BrushOrigin,
        r#BrushAxis,
        r#Rotation,
        r#Option,
    }
}

codec! {
    pub struct BuilderToolFloatArg {
        pub r#defaultValue: f32,
        pub r#min: f32,
        pub r#max: f32,
    }
}

codec! {
    pub struct BuilderToolOptionArg {
        pub r#defaultValue: Option<String>,
        pub r#options: Option<Vec<String>>,
    }
}

codec! {
    pub struct ItemEntityConfig {
        pub r#particleSystemId: Option<String>,
        pub r#particleColor: Option<Color>,
        pub r#showItemParticles: bool,
    }
}

codec! {
    pub struct ModelTrail {
        pub r#trailId: Option<String>,
        pub r#targetEntityPart: EntityPart,
        pub r#targetNodeName: Option<String>,
        pub r#positionOffset: Option<Vector3f>,
        pub r#rotationOffset: Option<Direction>,
        pub r#fixedRotation: bool,
    }
}

codec! {
    pub struct InteractionConfiguration {
        pub r#displayOutlines: bool,
        pub r#debugOutlines: bool,
        pub r#useDistance: Option<Dictionary<GameMode, f32>>,
        pub r#allEntities: bool,
        pub r#priorities: Option<Dictionary<InteractionType, InteractionPriority>>,
    }
}

codec! {
    pub enum GameMode {
        r#Adventure,
        r#Creative,
    }
}

codec! {
    pub struct InteractionPriority {
        pub r#values: Option<Dictionary<PrioritySlot, u32>>,
    }
}

codec! {
    pub enum PrioritySlot {
        r#Default,
        r#MainHand,
        r#OffHand,
    }
}

codec! {
    pub struct ItemAppearanceCondition {
        pub r#particles: Option<Vec<ModelParticle>>,
        pub r#firstPersonParticles: Option<Vec<ModelParticle>>,
        pub r#model: Option<String>,
        pub r#texture: Option<String>,
        pub r#modelVFXId: Option<String>,
        pub r#condition: Option<FloatRange>,
        pub r#conditionValueType: ValueType,
        pub r#localSoundEventId: u32,
        pub r#worldSoundEventId: u32,
    }
}

codec! {
    pub struct UpdateItemQualities {
        pub r#type: UpdateType,
        pub r#maxId: u32,
        pub r#itemQualities: Option<Dictionary<u32, ItemQuality>>,
    }
}

impl Packet for UpdateItemQualities {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "UpdateItemQualities",
        id: 55,
        is_compressed: true,
        max_size: 1677721600,
        category: PacketCategory::ASSETS,
    };
}

codec! {
    pub struct ItemQuality {
        pub r#id: Option<String>,
        pub r#itemTooltipTexture: Option<String>,
        pub r#itemTooltipArrowTexture: Option<String>,
        pub r#slotTexture: Option<String>,
        pub r#blockSlotTexture: Option<String>,
        pub r#specialSlotTexture: Option<String>,
        pub r#textColor: Option<Color>,
        pub r#localizationKey: Option<String>,
        pub r#visibleQualityLabel: bool,
        pub r#renderSpecialSlot: bool,
        pub r#hideFromSearch: bool,
    }
}

codec! {
    pub struct UpdateItemCategories {
        pub r#type: UpdateType,
        pub r#itemCategories: Option<Vec<ItemCategory>>,
    }
}

impl Packet for UpdateItemCategories {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "UpdateItemCategories",
        id: 56,
        is_compressed: true,
        max_size: 1677721600,
        category: PacketCategory::ASSETS,
    };
}

codec! {
    pub struct ItemCategory {
        pub r#id: Option<String>,
        pub r#name: Option<String>,
        pub r#icon: Option<String>,
        pub r#order: u32,
        pub r#infoDisplayMode: ItemGridInfoDisplayMode,
        pub r#children: Option<Vec<ItemCategory>>,
    }
}

codec! {
    pub enum ItemGridInfoDisplayMode {
        r#Tooltip,
        r#Adjacent,
        r#None,
    }
}

codec! {
    pub struct UpdateItemReticles {
        pub r#type: UpdateType,
        pub r#maxId: u32,
        pub r#itemReticleConfigs: Option<Dictionary<u32, ItemReticleConfig>>,
    }
}

impl Packet for UpdateItemReticles {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "UpdateItemReticles",
        id: 57,
        is_compressed: true,
        max_size: 1677721600,
        category: PacketCategory::ASSETS,
    };
}

codec! {
    pub struct ItemReticleConfig {
        pub r#id: Option<String>,
        pub r#base: Option<Vec<String>>,
        pub r#serverEvents: Option<Dictionary<u32, ItemReticle>>,
        pub r#clientEvents: Option<Dictionary<ItemReticleClientEvent, ItemReticle>>,
    }
}

codec! {
    pub struct ItemReticle {
        pub r#hideBase: bool,
        pub r#parts: Option<Vec<String>>,
        pub r#duration: f32,
    }
}

codec! {
    pub enum ItemReticleClientEvent {
        r#OnHit,
        r#Wielding,
        r#OnMovementLeft,
        r#OnMovementRight,
        r#OnMovementBack,
    }
}

codec! {
    pub struct UpdateFieldcraftCategories {
        pub r#type: UpdateType,
        pub r#itemCategories: Option<Vec<ItemCategory>>,
    }
}

impl Packet for UpdateFieldcraftCategories {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "UpdateFieldcraftCategories",
        id: 58,
        is_compressed: true,
        max_size: 1677721600,
        category: PacketCategory::ASSETS,
    };
}

codec! {
    pub struct UpdateResourceTypes {
        pub r#type: UpdateType,
        pub r#resourceTypes: Option<Dictionary<String, ResourceType>>,
    }
}

impl Packet for UpdateResourceTypes {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "UpdateResourceTypes",
        id: 59,
        is_compressed: true,
        max_size: 1677721600,
        category: PacketCategory::ASSETS,
    };
}

codec! {
    pub struct ResourceType {
        pub r#id: Option<String>,
        pub r#icon: Option<String>,
    }
}

codec! {
    pub struct UpdateRecipes {
        pub r#type: UpdateType,
        pub r#recipes: Option<Dictionary<String, CraftingRecipe>>,
        pub r#removedRecipes: Option<Vec<String>>,
    }
}

impl Packet for UpdateRecipes {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "UpdateRecipes",
        id: 60,
        is_compressed: true,
        max_size: 1677721600,
        category: PacketCategory::ASSETS,
    };
}

codec! {
    pub struct CraftingRecipe {
        pub r#id: Option<String>,
        pub r#inputs: Option<Vec<MaterialQuantity>>,
        pub r#outputs: Option<Vec<MaterialQuantity>>,
        pub r#primaryOutput: Option<MaterialQuantity>,
        pub r#benchRequirement: Option<Vec<BenchRequirement>>,
        pub r#knowledgeRequired: bool,
        pub r#timeSeconds: f32,
        pub r#requiredMemoriesLevel: u32,
    }
}

codec! {
    pub struct BenchRequirement {
        pub r#type: BenchType,
        pub r#id: Option<String>,
        pub r#categories: Option<Vec<String>>,
        pub r#requiredTierLevel: u32,
    }
}

codec! {
    pub enum BenchType {
        r#Crafting,
        r#Processing,
        r#DiagramCrafting,
        r#StructuralCrafting,
    }
}

codec! {
    pub struct UpdateEnvironments {
        pub r#type: UpdateType,
        pub r#maxId: u32,
        pub r#environments: Option<Dictionary<u32, WorldEnvironment>>,
        pub r#rebuildMapGeometry: bool,
    }
}

impl Packet for UpdateEnvironments {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "UpdateEnvironments",
        id: 61,
        is_compressed: true,
        max_size: 1677721600,
        category: PacketCategory::ASSETS,
    };
}

codec! {
    pub struct WorldEnvironment {
        pub r#id: Option<String>,
        pub r#waterTint: Option<Color>,
        pub r#fluidParticles: Option<Dictionary<u32, FluidParticle>>,
        pub r#tagIndexes: Option<Vec<u32>>,
    }
}

codec! {
    pub struct FluidParticle {
        pub r#systemId: Option<String>,
        pub r#color: Option<Color>,
        pub r#scale: f32,
    }
}

codec! {
    pub struct UpdateAmbienceFX {
        pub r#type: UpdateType,
        pub r#maxId: u32,
        pub r#ambienceFX: Option<Dictionary<u32, AmbienceFX>>,
    }
}

impl Packet for UpdateAmbienceFX {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "UpdateAmbienceFX",
        id: 62,
        is_compressed: true,
        max_size: 1677721600,
        category: PacketCategory::ASSETS,
    };
}

codec! {
    pub struct AmbienceFX {
        pub r#id: Option<String>,
        pub r#conditions: Option<AmbienceFXConditions>,
        pub r#sounds: Option<Vec<AmbienceFXSound>>,
        pub r#music: Option<AmbienceFXMusic>,
        pub r#ambientBed: Option<AmbienceFXAmbientBed>,
        pub r#soundEffect: Option<AmbienceFXSoundEffect>,
        pub r#priority: u32,
        pub r#blockedAmbienceFxIndices: Option<Vec<u32>>,
        pub r#audioCategoryIndex: u32,
    }
}

codec! {
    pub struct AmbienceFXConditions {
        pub r#never: bool,
        pub r#environmentIndices: Option<Vec<u32>>,
        pub r#weatherIndices: Option<Vec<u32>>,
        pub r#fluidFXIndices: Option<Vec<u32>>,
        pub r#environmentTagPatternIndex: u32,
        pub r#weatherTagPatternIndex: u32,
        pub r#surroundingBlockSoundSets: Option<Vec<AmbienceFXBlockSoundSet>>,
        pub r#altitude: Option<Range>,
        pub r#walls: Option<Rangeb>,
        pub r#roof: bool,
        pub r#roofMaterialTagPatternIndex: u32,
        pub r#floor: bool,
        pub r#sunLightLevel: Option<Rangeb>,
        pub r#torchLightLevel: Option<Rangeb>,
        pub r#globalLightLevel: Option<Rangeb>,
        pub r#dayTime: Option<Rangef>,
    }
}

codec! {
    pub struct AmbienceFXBlockSoundSet {
        pub r#blockSoundSetIndex: u32,
        pub r#percent: Option<Rangef>,
    }
}

codec! {
    pub struct Rangeb {
        @small = true;
        pub r#min: u8,
        pub r#max: u8,
    }
}

codec! {
    pub struct AmbienceFXSound {
        pub r#soundEventIndex: u32,
        pub r#play3D: AmbienceFXSoundPlay3D,
        pub r#blockSoundSetIndex: u32,
        pub r#altitude: AmbienceFXAltitude,
        pub r#frequency: Option<Rangef>,
        pub r#radius: Option<Range>,
    }
}

codec! {
    pub enum AmbienceFXSoundPlay3D {
        r#Random,
        r#LocationName,
        r#No,
    }
}

codec! {
    pub enum AmbienceFXAltitude {
        r#Normal,
        r#Lowest,
        r#Highest,
        r#Random,
    }
}

codec! {
    pub struct AmbienceFXMusic {
        pub r#tracks: Option<Vec<String>>,
        pub r#volume: f32,
    }
}

codec! {
    pub struct AmbienceFXAmbientBed {
        pub r#track: Option<String>,
        pub r#volume: f32,
        pub r#transitionSpeed: AmbienceTransitionSpeed,
    }
}

codec! {
    pub enum AmbienceTransitionSpeed {
        r#Default,
        r#Fast,
        r#Instant,
    }
}

codec! {
    pub struct AmbienceFXSoundEffect {
        @small = true;
        pub r#reverbEffectIndex: u32,
        pub r#equalizerEffectIndex: u32,
        pub r#isInstant: bool,
    }
}

codec! {
    pub struct UpdateFluidFX {
        pub r#type: UpdateType,
        pub r#maxId: u32,
        pub r#fluidFX: Option<Dictionary<u32, FluidFX>>,
    }
}

impl Packet for UpdateFluidFX {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "UpdateFluidFX",
        id: 63,
        is_compressed: true,
        max_size: 1677721600,
        category: PacketCategory::ASSETS,
    };
}

codec! {
    pub struct FluidFX {
        pub r#id: Option<String>,
        pub r#shader: ShaderType,
        pub r#fogMode: FluidFog,
        pub r#fogColor: Option<Color>,
        pub r#fogDistance: Option<NearFar>,
        pub r#fogDepthStart: f32,
        pub r#fogDepthFalloff: f32,
        pub r#colorFilter: Option<Color>,
        pub r#colorSaturation: f32,
        pub r#distortionAmplitude: f32,
        pub r#distortionFrequency: f32,
        pub r#particle: Option<FluidParticle>,
        pub r#movementSettings: Option<FluidFXMovementSettings>,
    }
}

codec! {
    pub enum FluidFog {
        r#Color,
        r#ColorLight,
        r#EnvironmentTint,
    }
}

codec! {
    pub struct FluidFXMovementSettings {
        @small = true;
        pub r#swimUpSpeed: f32,
        pub r#swimDownSpeed: f32,
        pub r#sinkSpeed: f32,
        pub r#horizontalSpeedMultiplier: f32,
        pub r#fieldOfViewMultiplier: f32,
        pub r#entryVelocityMultiplier: f32,
    }
}

codec! {
    pub struct UpdateTranslations {
        pub r#type: UpdateType,
        pub r#translations: Option<Dictionary<String, String>>,
    }
}

impl Packet for UpdateTranslations {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "UpdateTranslations",
        id: 64,
        is_compressed: true,
        max_size: 1677721600,
        category: PacketCategory::ASSETS,
    };
}

codec! {
    pub struct UpdateSoundEvents {
        pub r#type: UpdateType,
        pub r#maxId: u32,
        pub r#soundEvents: Option<Dictionary<u32, SoundEvent>>,
    }
}

impl Packet for UpdateSoundEvents {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "UpdateSoundEvents",
        id: 65,
        is_compressed: true,
        max_size: 1677721600,
        category: PacketCategory::ASSETS,
    };
}

codec! {
    pub struct SoundEvent {
        pub r#id: Option<String>,
        pub r#volume: f32,
        pub r#pitch: f32,
        pub r#musicDuckingVolume: f32,
        pub r#ambientDuckingVolume: f32,
        pub r#maxInstance: u32,
        pub r#preventSoundInterruption: bool,
        pub r#startAttenuationDistance: f32,
        pub r#maxDistance: f32,
        pub r#layers: Option<Vec<SoundEventLayer>>,
        pub r#audioCategory: u32,
    }
}

codec! {
    pub struct SoundEventLayer {
        pub r#volume: f32,
        pub r#startDelay: f32,
        pub r#looping: bool,
        pub r#probability: u32,
        pub r#probabilityRerollDelay: f32,
        pub r#roundRobinHistorySize: u32,
        pub r#randomSettings: Option<SoundEventLayerRandomSettings>,
        pub r#files: Option<Vec<String>>,
    }
}

codec! {
    pub struct SoundEventLayerRandomSettings {
        @small = true;
        pub r#minVolume: f32,
        pub r#maxVolume: f32,
        pub r#minPitch: f32,
        pub r#maxPitch: f32,
        pub r#maxStartOffset: f32,
    }
}

codec! {
    pub struct UpdateInteractions {
        pub r#type: UpdateType,
        pub r#maxId: u32,
        pub r#interactions: Option<Dictionary<u32, Interaction>>,
    }
}

impl Packet for UpdateInteractions {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "UpdateInteractions",
        id: 66,
        is_compressed: true,
        max_size: 1677721600,
        category: PacketCategory::ASSETS,
    };
}

codec! {
    pub union Interaction {
        SimpleBlockInteraction(SimpleBlockInteraction),
        SimpleInteraction(SimpleInteraction),
        PlaceBlockInteraction(PlaceBlockInteraction),
        BreakBlockInteraction(BreakBlockInteraction),
        PickBlockInteraction(PickBlockInteraction),
        UseBlockInteraction(UseBlockInteraction),
        UseEntityInteraction(UseEntityInteraction),
        BuilderToolInteraction(BuilderToolInteraction),
        ModifyInventoryInteraction(ModifyInventoryInteraction),
        ChargingInteraction(ChargingInteraction),
        WieldingInteraction(WieldingInteraction),
        ChainingInteraction(ChainingInteraction),
        ConditionInteraction(ConditionInteraction),
        StatsConditionInteraction(StatsConditionInteraction),
        BlockConditionInteraction(BlockConditionInteraction),
        ReplaceInteraction(ReplaceInteraction),
        ChangeBlockInteraction(ChangeBlockInteraction),
        ChangeStateInteraction(ChangeStateInteraction),
        FirstClickInteraction(FirstClickInteraction),
        SelectInteraction(SelectInteraction),
        DamageEntityInteraction(DamageEntityInteraction),
        RepeatInteraction(RepeatInteraction),
        ParallelInteraction(ParallelInteraction),
        ChangeActiveSlotInteraction(ChangeActiveSlotInteraction),
        EffectConditionInteraction(EffectConditionInteraction),
        ApplyForceInteraction(ApplyForceInteraction),
        ApplyEffectInteraction(ApplyEffectInteraction),
        ClearEntityEffectInteraction(ClearEntityEffectInteraction),
        SerialInteraction(SerialInteraction),
        ChangeStatInteraction(ChangeStatInteraction),
        MovementConditionInteraction(MovementConditionInteraction),
        ProjectileInteraction(ProjectileInteraction),
        RemoveEntityInteraction(RemoveEntityInteraction),
        ResetCooldownInteraction(ResetCooldownInteraction),
        TriggerCooldownInteraction(TriggerCooldownInteraction),
        CooldownConditionInteraction(CooldownConditionInteraction),
        ChainFlagInteraction(ChainFlagInteraction),
        IncrementCooldownInteraction(IncrementCooldownInteraction),
        CancelChainInteraction(CancelChainInteraction),
        RunRootInteraction(RunRootInteraction),
        CameraInteraction(CameraInteraction),
        SpawnDeployableFromRaycastInteraction(SpawnDeployableFromRaycastInteraction),
        MemoriesConditionInteraction(MemoriesConditionInteraction),
        ToggleGliderInteraction(ToggleGliderInteraction),
    }
}

codec! {
    pub struct SimpleBlockInteraction {
        pub r#waitForDataFrom: WaitForDataFrom,
        pub r#effects: Option<InteractionEffects>,
        pub r#horizontalSpeedMultiplier: f32,
        pub r#runTime: f32,
        pub r#cancelOnItemChange: bool,
        pub r#settings: Option<Dictionary<GameMode, InteractionSettings>>,
        pub r#rules: Option<InteractionRules>,
        pub r#tags: Option<Vec<u32>>,
        pub r#camera: Option<InteractionCameraSettings>,
        pub r#next: u32,
        pub r#failed: u32,
        pub r#useLatestTarget: bool,
    }
}

codec! {
    pub enum WaitForDataFrom {
        r#Client,
        r#Server,
        r#None,
    }
}

codec! {
    pub struct InteractionEffects {
        pub r#particles: Option<Vec<ModelParticle>>,
        pub r#firstPersonParticles: Option<Vec<ModelParticle>>,
        pub r#worldSoundEventIndex: u32,
        pub r#localSoundEventIndex: u32,
        pub r#trails: Option<Vec<ModelTrail>>,
        pub r#waitForAnimationToFinish: bool,
        pub r#itemPlayerAnimationsId: Option<String>,
        pub r#itemAnimationId: Option<String>,
        pub r#clearAnimationOnFinish: bool,
        pub r#clearSoundEventOnFinish: bool,
        pub r#cameraShake: Option<CameraShakeEffect>,
        pub r#movementEffects: Option<MovementEffects>,
        pub r#startDelay: f32,
    }
}

codec! {
    pub struct CameraShakeEffect {
        @small = true;
        pub r#cameraShakeId: u32,
        pub r#intensity: f32,
        pub r#mode: AccumulationMode,
    }
}

impl Packet for CameraShakeEffect {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "CameraShakeEffect",
        id: 281,
        is_compressed: false,
        max_size: 9,
        category: PacketCategory::CAMERA,
    };
}

codec! {
    pub enum AccumulationMode {
        r#Set,
        r#Sum,
        r#Average,
    }
}

codec! {
    pub struct InteractionSettings {
        pub r#allowSkipOnClick: bool,
    }
}

codec! {
    pub struct InteractionRules {
        pub r#blockedBy: Option<Vec<InteractionType>>,
        pub r#blocking: Option<Vec<InteractionType>>,
        pub r#interruptedBy: Option<Vec<InteractionType>>,
        pub r#interrupting: Option<Vec<InteractionType>>,
        pub r#blockedByBypassIndex: u32,
        pub r#blockingBypassIndex: u32,
        pub r#interruptedByBypassIndex: u32,
        pub r#interruptingBypassIndex: u32,
    }
}

codec! {
    pub struct InteractionCameraSettings {
        pub r#firstPerson: Option<Vec<InteractionCamera>>,
        pub r#thirdPerson: Option<Vec<InteractionCamera>>,
    }
}

codec! {
    pub struct InteractionCamera {
        pub r#time: f32,
        pub r#position: Option<Vector3f>,
        pub r#rotation: Option<Direction>,
    }
}

codec! {
    pub struct SimpleInteraction {
        pub r#waitForDataFrom: WaitForDataFrom,
        pub r#effects: Option<InteractionEffects>,
        pub r#horizontalSpeedMultiplier: f32,
        pub r#runTime: f32,
        pub r#cancelOnItemChange: bool,
        pub r#settings: Option<Dictionary<GameMode, InteractionSettings>>,
        pub r#rules: Option<InteractionRules>,
        pub r#tags: Option<Vec<u32>>,
        pub r#camera: Option<InteractionCameraSettings>,
        pub r#next: u32,
        pub r#failed: u32,
    }
}

codec! {
    pub struct PlaceBlockInteraction {
        pub r#waitForDataFrom: WaitForDataFrom,
        pub r#effects: Option<InteractionEffects>,
        pub r#horizontalSpeedMultiplier: f32,
        pub r#runTime: f32,
        pub r#cancelOnItemChange: bool,
        pub r#settings: Option<Dictionary<GameMode, InteractionSettings>>,
        pub r#rules: Option<InteractionRules>,
        pub r#tags: Option<Vec<u32>>,
        pub r#camera: Option<InteractionCameraSettings>,
        pub r#next: u32,
        pub r#failed: u32,
        pub r#blockId: u32,
        pub r#removeItemInHand: bool,
        pub r#allowDragPlacement: bool,
    }
}

codec! {
    pub struct BreakBlockInteraction {
        pub r#waitForDataFrom: WaitForDataFrom,
        pub r#effects: Option<InteractionEffects>,
        pub r#horizontalSpeedMultiplier: f32,
        pub r#runTime: f32,
        pub r#cancelOnItemChange: bool,
        pub r#settings: Option<Dictionary<GameMode, InteractionSettings>>,
        pub r#rules: Option<InteractionRules>,
        pub r#tags: Option<Vec<u32>>,
        pub r#camera: Option<InteractionCameraSettings>,
        pub r#next: u32,
        pub r#failed: u32,
        pub r#useLatestTarget: bool,
        pub r#harvest: bool,
    }
}

codec! {
    pub struct PickBlockInteraction {
        pub r#waitForDataFrom: WaitForDataFrom,
        pub r#effects: Option<InteractionEffects>,
        pub r#horizontalSpeedMultiplier: f32,
        pub r#runTime: f32,
        pub r#cancelOnItemChange: bool,
        pub r#settings: Option<Dictionary<GameMode, InteractionSettings>>,
        pub r#rules: Option<InteractionRules>,
        pub r#tags: Option<Vec<u32>>,
        pub r#camera: Option<InteractionCameraSettings>,
        pub r#next: u32,
        pub r#failed: u32,
        pub r#useLatestTarget: bool,
    }
}

codec! {
    pub struct UseBlockInteraction {
        pub r#waitForDataFrom: WaitForDataFrom,
        pub r#effects: Option<InteractionEffects>,
        pub r#horizontalSpeedMultiplier: f32,
        pub r#runTime: f32,
        pub r#cancelOnItemChange: bool,
        pub r#settings: Option<Dictionary<GameMode, InteractionSettings>>,
        pub r#rules: Option<InteractionRules>,
        pub r#tags: Option<Vec<u32>>,
        pub r#camera: Option<InteractionCameraSettings>,
        pub r#next: u32,
        pub r#failed: u32,
        pub r#useLatestTarget: bool,
    }
}

codec! {
    pub struct UseEntityInteraction {
        pub r#waitForDataFrom: WaitForDataFrom,
        pub r#effects: Option<InteractionEffects>,
        pub r#horizontalSpeedMultiplier: f32,
        pub r#runTime: f32,
        pub r#cancelOnItemChange: bool,
        pub r#settings: Option<Dictionary<GameMode, InteractionSettings>>,
        pub r#rules: Option<InteractionRules>,
        pub r#tags: Option<Vec<u32>>,
        pub r#camera: Option<InteractionCameraSettings>,
        pub r#next: u32,
        pub r#failed: u32,
    }
}

codec! {
    pub struct BuilderToolInteraction {
        pub r#waitForDataFrom: WaitForDataFrom,
        pub r#effects: Option<InteractionEffects>,
        pub r#horizontalSpeedMultiplier: f32,
        pub r#runTime: f32,
        pub r#cancelOnItemChange: bool,
        pub r#settings: Option<Dictionary<GameMode, InteractionSettings>>,
        pub r#rules: Option<InteractionRules>,
        pub r#tags: Option<Vec<u32>>,
        pub r#camera: Option<InteractionCameraSettings>,
        pub r#next: u32,
        pub r#failed: u32,
    }
}

codec! {
    pub struct ModifyInventoryInteraction {
        pub r#waitForDataFrom: WaitForDataFrom,
        pub r#effects: Option<InteractionEffects>,
        pub r#horizontalSpeedMultiplier: f32,
        pub r#runTime: f32,
        pub r#cancelOnItemChange: bool,
        pub r#settings: Option<Dictionary<GameMode, InteractionSettings>>,
        pub r#rules: Option<InteractionRules>,
        pub r#tags: Option<Vec<u32>>,
        pub r#camera: Option<InteractionCameraSettings>,
        pub r#next: u32,
        pub r#failed: u32,
        pub r#requiredGameMode: Option<GameMode>,
        pub r#itemToRemove: Option<ItemWithAllMetadata>,
        pub r#adjustHeldItemQuantity: u32,
        pub r#itemToAdd: Option<ItemWithAllMetadata>,
        pub r#brokenItem: Option<String>,
        pub r#adjustHeldItemDurability: f64,
    }
}

codec! {
    pub struct ItemWithAllMetadata {
        pub r#itemId: String,
        pub r#quantity: u32,
        pub r#durability: f64,
        pub r#maxDurability: f64,
        pub r#overrideDroppedItemAnimation: bool,
        pub r#metadata: Option<String>,
    }
}

codec! {
    pub struct ChargingInteraction {
        pub r#waitForDataFrom: WaitForDataFrom,
        pub r#effects: Option<InteractionEffects>,
        pub r#horizontalSpeedMultiplier: f32,
        pub r#runTime: f32,
        pub r#cancelOnItemChange: bool,
        pub r#settings: Option<Dictionary<GameMode, InteractionSettings>>,
        pub r#rules: Option<InteractionRules>,
        pub r#tags: Option<Vec<u32>>,
        pub r#camera: Option<InteractionCameraSettings>,
        pub r#failed: u32,
        pub r#allowIndefiniteHold: bool,
        pub r#displayProgress: bool,
        pub r#cancelOnOtherClick: bool,
        pub r#failOnDamage: bool,
        pub r#mouseSensitivityAdjustmentTarget: f32,
        pub r#mouseSensitivityAdjustmentDuration: f32,
        pub r#chargedNext: Option<Dictionary<f32, u32>>,
        pub r#forks: Option<Dictionary<InteractionType, u32>>,
        pub r#chargingDelay: Option<ChargingDelay>,
    }
}

codec! {
    pub struct ChargingDelay {
        pub r#minDelay: f32,
        pub r#maxDelay: f32,
        pub r#maxTotalDelay: f32,
        pub r#minHealth: f32,
        pub r#maxHealth: f32,
    }
}

codec! {
    pub struct WieldingInteraction {
        pub r#waitForDataFrom: WaitForDataFrom,
        pub r#effects: Option<InteractionEffects>,
        pub r#horizontalSpeedMultiplier: f32,
        pub r#runTime: f32,
        pub r#cancelOnItemChange: bool,
        pub r#settings: Option<Dictionary<GameMode, InteractionSettings>>,
        pub r#rules: Option<InteractionRules>,
        pub r#tags: Option<Vec<u32>>,
        pub r#camera: Option<InteractionCameraSettings>,
        pub r#failed: u32,
        pub r#allowIndefiniteHold: bool,
        pub r#displayProgress: bool,
        pub r#cancelOnOtherClick: bool,
        pub r#failOnDamage: bool,
        pub r#mouseSensitivityAdjustmentTarget: f32,
        pub r#mouseSensitivityAdjustmentDuration: f32,
        pub r#chargedNext: Option<Dictionary<f32, u32>>,
        pub r#forks: Option<Dictionary<InteractionType, u32>>,
        pub r#chargingDelay: Option<ChargingDelay>,
        pub r#blockedEffects: Option<DamageEffects>,
        pub r#hasModifiers: bool,
        pub r#angledWielding: Option<AngledWielding>,
    }
}

codec! {
    pub struct DamageEffects {
        pub r#modelParticles: Option<Vec<ModelParticle>>,
        pub r#worldParticles: Option<Vec<WorldParticle>>,
        pub r#soundEventIndex: u32,
    }
}

codec! {
    pub struct WorldParticle {
        pub r#systemId: Option<String>,
        pub r#scale: f32,
        pub r#color: Option<Color>,
        pub r#positionOffset: Option<Vector3f>,
        pub r#rotationOffset: Option<Direction>,
    }
}

codec! {
    pub struct AngledWielding {
        pub r#angleRad: f32,
        pub r#angleDistanceRad: f32,
        pub r#hasModifiers: bool,
    }
}

codec! {
    pub struct ChainingInteraction {
        pub r#waitForDataFrom: WaitForDataFrom,
        pub r#effects: Option<InteractionEffects>,
        pub r#horizontalSpeedMultiplier: f32,
        pub r#runTime: f32,
        pub r#cancelOnItemChange: bool,
        pub r#settings: Option<Dictionary<GameMode, InteractionSettings>>,
        pub r#rules: Option<InteractionRules>,
        pub r#tags: Option<Vec<u32>>,
        pub r#camera: Option<InteractionCameraSettings>,
        pub r#chainId: Option<String>,
        pub r#chainingAllowance: f32,
        pub r#chainingNext: Option<Vec<u32>>,
        pub r#flags: Option<Dictionary<String, u32>>,
    }
}

codec! {
    pub struct ConditionInteraction {
        pub r#waitForDataFrom: WaitForDataFrom,
        pub r#effects: Option<InteractionEffects>,
        pub r#horizontalSpeedMultiplier: f32,
        pub r#runTime: f32,
        pub r#cancelOnItemChange: bool,
        pub r#settings: Option<Dictionary<GameMode, InteractionSettings>>,
        pub r#rules: Option<InteractionRules>,
        pub r#tags: Option<Vec<u32>>,
        pub r#camera: Option<InteractionCameraSettings>,
        pub r#next: u32,
        pub r#failed: u32,
        pub r#requiredGameMode: Option<GameMode>,
        pub r#jumping: Option<bool>,
        pub r#swimming: Option<bool>,
        pub r#crouching: Option<bool>,
        pub r#running: Option<bool>,
        pub r#flying: Option<bool>,
    }
}

codec! {
    pub struct StatsConditionInteraction {
        pub r#waitForDataFrom: WaitForDataFrom,
        pub r#effects: Option<InteractionEffects>,
        pub r#horizontalSpeedMultiplier: f32,
        pub r#runTime: f32,
        pub r#cancelOnItemChange: bool,
        pub r#settings: Option<Dictionary<GameMode, InteractionSettings>>,
        pub r#rules: Option<InteractionRules>,
        pub r#tags: Option<Vec<u32>>,
        pub r#camera: Option<InteractionCameraSettings>,
        pub r#next: u32,
        pub r#failed: u32,
        pub r#costs: Option<Dictionary<u32, f32>>,
        pub r#lessThan: bool,
        pub r#lenient: bool,
        pub r#valueType: ValueType,
    }
}

codec! {
    pub struct BlockConditionInteraction {
        pub r#waitForDataFrom: WaitForDataFrom,
        pub r#effects: Option<InteractionEffects>,
        pub r#horizontalSpeedMultiplier: f32,
        pub r#runTime: f32,
        pub r#cancelOnItemChange: bool,
        pub r#settings: Option<Dictionary<GameMode, InteractionSettings>>,
        pub r#rules: Option<InteractionRules>,
        pub r#tags: Option<Vec<u32>>,
        pub r#camera: Option<InteractionCameraSettings>,
        pub r#next: u32,
        pub r#failed: u32,
        pub r#useLatestTarget: bool,
        pub r#matchers: Option<Vec<BlockMatcher>>,
    }
}

codec! {
    pub struct BlockMatcher {
        pub r#block: Option<BlockIdMatcher>,
        pub r#face: BlockFace,
        pub r#staticFace: bool,
    }
}

codec! {
    pub struct BlockIdMatcher {
        pub r#id: Option<String>,
        pub r#state: Option<String>,
        pub r#tagIndex: u32,
    }
}

codec! {
    pub enum BlockFace {
        r#None,
        r#Up,
        r#Down,
        r#North,
        r#South,
        r#East,
        r#West,
    }
}

codec! {
    pub struct ReplaceInteraction {
        pub r#waitForDataFrom: WaitForDataFrom,
        pub r#effects: Option<InteractionEffects>,
        pub r#horizontalSpeedMultiplier: f32,
        pub r#runTime: f32,
        pub r#cancelOnItemChange: bool,
        pub r#settings: Option<Dictionary<GameMode, InteractionSettings>>,
        pub r#rules: Option<InteractionRules>,
        pub r#tags: Option<Vec<u32>>,
        pub r#camera: Option<InteractionCameraSettings>,
        pub r#defaultValue: u32,
        pub r#variable: Option<String>,
    }
}

codec! {
    pub struct ChangeBlockInteraction {
        pub r#waitForDataFrom: WaitForDataFrom,
        pub r#effects: Option<InteractionEffects>,
        pub r#horizontalSpeedMultiplier: f32,
        pub r#runTime: f32,
        pub r#cancelOnItemChange: bool,
        pub r#settings: Option<Dictionary<GameMode, InteractionSettings>>,
        pub r#rules: Option<InteractionRules>,
        pub r#tags: Option<Vec<u32>>,
        pub r#camera: Option<InteractionCameraSettings>,
        pub r#next: u32,
        pub r#failed: u32,
        pub r#useLatestTarget: bool,
        pub r#blockChanges: Option<Dictionary<u32, u32>>,
        pub r#worldSoundEventIndex: u32,
        pub r#requireNotBroken: bool,
    }
}

codec! {
    pub struct ChangeStateInteraction {
        pub r#waitForDataFrom: WaitForDataFrom,
        pub r#effects: Option<InteractionEffects>,
        pub r#horizontalSpeedMultiplier: f32,
        pub r#runTime: f32,
        pub r#cancelOnItemChange: bool,
        pub r#settings: Option<Dictionary<GameMode, InteractionSettings>>,
        pub r#rules: Option<InteractionRules>,
        pub r#tags: Option<Vec<u32>>,
        pub r#camera: Option<InteractionCameraSettings>,
        pub r#next: u32,
        pub r#failed: u32,
        pub r#useLatestTarget: bool,
        pub r#stateChanges: Option<Dictionary<String, String>>,
    }
}

codec! {
    pub struct FirstClickInteraction {
        pub r#waitForDataFrom: WaitForDataFrom,
        pub r#effects: Option<InteractionEffects>,
        pub r#horizontalSpeedMultiplier: f32,
        pub r#runTime: f32,
        pub r#cancelOnItemChange: bool,
        pub r#settings: Option<Dictionary<GameMode, InteractionSettings>>,
        pub r#rules: Option<InteractionRules>,
        pub r#tags: Option<Vec<u32>>,
        pub r#camera: Option<InteractionCameraSettings>,
        pub r#click: u32,
        pub r#held: u32,
    }
}

codec! {
    pub struct SelectInteraction {
        pub r#waitForDataFrom: WaitForDataFrom,
        pub r#effects: Option<InteractionEffects>,
        pub r#horizontalSpeedMultiplier: f32,
        pub r#runTime: f32,
        pub r#cancelOnItemChange: bool,
        pub r#settings: Option<Dictionary<GameMode, InteractionSettings>>,
        pub r#rules: Option<InteractionRules>,
        pub r#tags: Option<Vec<u32>>,
        pub r#camera: Option<InteractionCameraSettings>,
        pub r#next: u32,
        pub r#failed: u32,
        pub r#selector: Option<Selector>,
        pub r#ignoreOwner: bool,
        pub r#hitEntity: u32,
        pub r#hitEntityRules: Option<Vec<HitEntity>>,
        pub r#failOn: FailOnType,
    }
}

codec! {
    pub union Selector {
        AOECircleSelector(AOECircleSelector),
        AOECylinderSelector(AOECylinderSelector),
        RaycastSelector(RaycastSelector),
        HorizontalSelector(HorizontalSelector),
        StabSelector(StabSelector),
    }
}

codec! {
    pub struct AOECircleSelector {
        pub r#range: f32,
        pub r#offset: Option<Vector3f>,
    }
}

codec! {
    pub struct AOECylinderSelector {
        pub r#range: f32,
        pub r#height: f32,
        pub r#offset: Option<Vector3f>,
    }
}

codec! {
    pub struct RaycastSelector {
        pub r#offset: Option<Vector3f>,
        pub r#distance: u32,
        pub r#blockTagIndex: u32,
        pub r#ignoreFluids: bool,
        pub r#ignoreEmptyCollisionMaterial: bool,
    }
}

codec! {
    pub struct HorizontalSelector {
        pub r#extendTop: f32,
        pub r#extendBottom: f32,
        pub r#yawLength: f32,
        pub r#yawStartOffset: f32,
        pub r#pitchOffset: f32,
        pub r#rollOffset: f32,
        pub r#startDistance: f32,
        pub r#endDistance: f32,
        pub r#direction: HorizontalSelectorDirection,
        pub r#testLineOfSight: bool,
    }
}

codec! {
    pub enum HorizontalSelectorDirection {
        r#ToLeft,
        r#ToRight,
    }
}

codec! {
    pub struct StabSelector {
        pub r#extendTop: f32,
        pub r#extendBottom: f32,
        pub r#extendLeft: f32,
        pub r#extendRight: f32,
        pub r#yawOffset: f32,
        pub r#pitchOffset: f32,
        pub r#rollOffset: f32,
        pub r#startDistance: f32,
        pub r#endDistance: f32,
        pub r#testLineOfSight: bool,
    }
}

codec! {
    pub struct HitEntity {
        pub r#next: u32,
        pub r#matchers: Option<Vec<EntityMatcher>>,
    }
}

codec! {
    pub struct EntityMatcher {
        pub r#type: EntityMatcherType,
        pub r#invert: bool,
    }
}

codec! {
    pub enum EntityMatcherType {
        r#Server,
        r#VulnerableMatcher,
        r#Player,
    }
}

codec! {
    pub enum FailOnType {
        r#Neither,
        r#Entity,
        r#Block,
        r#Either,
    }
}

codec! {
    pub struct DamageEntityInteraction {
        pub r#waitForDataFrom: WaitForDataFrom,
        pub r#effects: Option<InteractionEffects>,
        pub r#horizontalSpeedMultiplier: f32,
        pub r#runTime: f32,
        pub r#cancelOnItemChange: bool,
        pub r#settings: Option<Dictionary<GameMode, InteractionSettings>>,
        pub r#rules: Option<InteractionRules>,
        pub r#tags: Option<Vec<u32>>,
        pub r#camera: Option<InteractionCameraSettings>,
        pub r#next: u32,
        pub r#failed: u32,
        pub r#blocked: u32,
        pub r#damageEffects: Option<DamageEffects>,
        pub r#angledDamage: Option<Vec<AngledDamage>>,
        pub r#targetedDamage: Option<Dictionary<String, TargetedDamage>>,
        pub r#entityStatsOnHit: Option<Vec<EntityStatOnHit>>,
    }
}

codec! {
    pub struct AngledDamage {
        pub r#angle: f64,
        pub r#angleDistance: f64,
        pub r#damageEffects: Option<DamageEffects>,
        pub r#next: u32,
    }
}

codec! {
    pub struct TargetedDamage {
        pub r#index: u32,
        pub r#damageEffects: Option<DamageEffects>,
        pub r#next: u32,
    }
}

codec! {
    pub struct EntityStatOnHit {
        pub r#entityStatIndex: u32,
        pub r#amount: f32,
        pub r#multipliersPerEntitiesHit: Option<Vec<f32>>,
        pub r#multiplierPerExtraEntityHit: f32,
    }
}

codec! {
    pub struct RepeatInteraction {
        pub r#waitForDataFrom: WaitForDataFrom,
        pub r#effects: Option<InteractionEffects>,
        pub r#horizontalSpeedMultiplier: f32,
        pub r#runTime: f32,
        pub r#cancelOnItemChange: bool,
        pub r#settings: Option<Dictionary<GameMode, InteractionSettings>>,
        pub r#rules: Option<InteractionRules>,
        pub r#tags: Option<Vec<u32>>,
        pub r#camera: Option<InteractionCameraSettings>,
        pub r#next: u32,
        pub r#failed: u32,
        pub r#forkInteractions: u32,
        pub r#repeat: u32,
    }
}

codec! {
    pub struct ParallelInteraction {
        pub r#waitForDataFrom: WaitForDataFrom,
        pub r#effects: Option<InteractionEffects>,
        pub r#horizontalSpeedMultiplier: f32,
        pub r#runTime: f32,
        pub r#cancelOnItemChange: bool,
        pub r#settings: Option<Dictionary<GameMode, InteractionSettings>>,
        pub r#rules: Option<InteractionRules>,
        pub r#tags: Option<Vec<u32>>,
        pub r#camera: Option<InteractionCameraSettings>,
        pub r#next: Option<Vec<u32>>,
    }
}

codec! {
    pub struct ChangeActiveSlotInteraction {
        pub r#waitForDataFrom: WaitForDataFrom,
        pub r#effects: Option<InteractionEffects>,
        pub r#horizontalSpeedMultiplier: f32,
        pub r#runTime: f32,
        pub r#cancelOnItemChange: bool,
        pub r#settings: Option<Dictionary<GameMode, InteractionSettings>>,
        pub r#rules: Option<InteractionRules>,
        pub r#tags: Option<Vec<u32>>,
        pub r#camera: Option<InteractionCameraSettings>,
        pub r#targetSlot: u32,
    }
}

codec! {
    pub struct EffectConditionInteraction {
        pub r#waitForDataFrom: WaitForDataFrom,
        pub r#effects: Option<InteractionEffects>,
        pub r#horizontalSpeedMultiplier: f32,
        pub r#runTime: f32,
        pub r#cancelOnItemChange: bool,
        pub r#settings: Option<Dictionary<GameMode, InteractionSettings>>,
        pub r#rules: Option<InteractionRules>,
        pub r#tags: Option<Vec<u32>>,
        pub r#camera: Option<InteractionCameraSettings>,
        pub r#next: u32,
        pub r#failed: u32,
        pub r#entityEffects: Option<Vec<u32>>,
        pub r#match: Match,
        pub r#entityTarget: InteractionTarget,
    }
}

codec! {
    pub enum Match {
        r#All,
        r#None,
    }
}

codec! {
    pub enum InteractionTarget {
        r#User,
        r#Owner,
        r#Target,
    }
}

codec! {
    pub struct ApplyForceInteraction {
        pub r#waitForDataFrom: WaitForDataFrom,
        pub r#effects: Option<InteractionEffects>,
        pub r#horizontalSpeedMultiplier: f32,
        pub r#runTime: f32,
        pub r#cancelOnItemChange: bool,
        pub r#settings: Option<Dictionary<GameMode, InteractionSettings>>,
        pub r#rules: Option<InteractionRules>,
        pub r#tags: Option<Vec<u32>>,
        pub r#camera: Option<InteractionCameraSettings>,
        pub r#next: u32,
        pub r#failed: u32,
        pub r#velocityConfig: Option<VelocityConfig>,
        pub r#changeVelocityType: ChangeVelocityType,
        pub r#forces: Option<Vec<AppliedForce>>,
        pub r#duration: f32,
        pub r#verticalClamp: Option<FloatRange>,
        pub r#waitForGround: bool,
        pub r#waitForCollision: bool,
        pub r#groundCheckDelay: f32,
        pub r#collisionCheckDelay: f32,
        pub r#groundNext: u32,
        pub r#collisionNext: u32,
        pub r#raycastDistance: f32,
        pub r#raycastHeightOffset: f32,
        pub r#raycastMode: RaycastMode,
    }
}

codec! {
    pub struct VelocityConfig {
        @small = true;
        pub r#groundResistance: f32,
        pub r#groundResistanceMax: f32,
        pub r#airResistance: f32,
        pub r#airResistanceMax: f32,
        pub r#threshold: f32,
        pub r#style: VelocityThresholdStyle,
    }
}

codec! {
    pub enum VelocityThresholdStyle {
        r#Linear,
        r#Exp,
    }
}

codec! {
    pub enum ChangeVelocityType {
        r#Add,
        r#Set,
    }
}

codec! {
    pub struct AppliedForce {
        pub r#direction: Option<Vector3f>,
        pub r#adjustVertical: bool,
        pub r#force: f32,
    }
}

codec! {
    pub enum RaycastMode {
        r#FollowMotion,
        r#FollowLook,
    }
}

codec! {
    pub struct ApplyEffectInteraction {
        pub r#waitForDataFrom: WaitForDataFrom,
        pub r#effects: Option<InteractionEffects>,
        pub r#horizontalSpeedMultiplier: f32,
        pub r#runTime: f32,
        pub r#cancelOnItemChange: bool,
        pub r#settings: Option<Dictionary<GameMode, InteractionSettings>>,
        pub r#rules: Option<InteractionRules>,
        pub r#tags: Option<Vec<u32>>,
        pub r#camera: Option<InteractionCameraSettings>,
        pub r#next: u32,
        pub r#failed: u32,
        pub r#effectId: u32,
        pub r#entityTarget: InteractionTarget,
    }
}

codec! {
    pub struct ClearEntityEffectInteraction {
        pub r#waitForDataFrom: WaitForDataFrom,
        pub r#effects: Option<InteractionEffects>,
        pub r#horizontalSpeedMultiplier: f32,
        pub r#runTime: f32,
        pub r#cancelOnItemChange: bool,
        pub r#settings: Option<Dictionary<GameMode, InteractionSettings>>,
        pub r#rules: Option<InteractionRules>,
        pub r#tags: Option<Vec<u32>>,
        pub r#camera: Option<InteractionCameraSettings>,
        pub r#next: u32,
        pub r#failed: u32,
        pub r#effectId: u32,
        pub r#entityTarget: InteractionTarget,
    }
}

codec! {
    pub struct SerialInteraction {
        pub r#waitForDataFrom: WaitForDataFrom,
        pub r#effects: Option<InteractionEffects>,
        pub r#horizontalSpeedMultiplier: f32,
        pub r#runTime: f32,
        pub r#cancelOnItemChange: bool,
        pub r#settings: Option<Dictionary<GameMode, InteractionSettings>>,
        pub r#rules: Option<InteractionRules>,
        pub r#tags: Option<Vec<u32>>,
        pub r#camera: Option<InteractionCameraSettings>,
        pub r#serialInteractions: Option<Vec<u32>>,
    }
}

codec! {
    pub struct ChangeStatInteraction {
        pub r#waitForDataFrom: WaitForDataFrom,
        pub r#effects: Option<InteractionEffects>,
        pub r#horizontalSpeedMultiplier: f32,
        pub r#runTime: f32,
        pub r#cancelOnItemChange: bool,
        pub r#settings: Option<Dictionary<GameMode, InteractionSettings>>,
        pub r#rules: Option<InteractionRules>,
        pub r#tags: Option<Vec<u32>>,
        pub r#camera: Option<InteractionCameraSettings>,
        pub r#next: u32,
        pub r#failed: u32,
        pub r#entityTarget: InteractionTarget,
        pub r#valueType: ValueType,
        pub r#statModifiers: Option<Dictionary<u32, f32>>,
        pub r#changeStatBehaviour: ChangeStatBehaviour,
    }
}

codec! {
    pub enum ChangeStatBehaviour {
        r#Add,
        r#Set,
    }
}

codec! {
    pub struct MovementConditionInteraction {
        pub r#waitForDataFrom: WaitForDataFrom,
        pub r#effects: Option<InteractionEffects>,
        pub r#horizontalSpeedMultiplier: f32,
        pub r#runTime: f32,
        pub r#cancelOnItemChange: bool,
        pub r#settings: Option<Dictionary<GameMode, InteractionSettings>>,
        pub r#rules: Option<InteractionRules>,
        pub r#tags: Option<Vec<u32>>,
        pub r#camera: Option<InteractionCameraSettings>,
        pub r#next: u32,
        pub r#failed: u32,
        pub r#forward: u32,
        pub r#back: u32,
        pub r#left: u32,
        pub r#right: u32,
        pub r#forwardLeft: u32,
        pub r#forwardRight: u32,
        pub r#backLeft: u32,
        pub r#backRight: u32,
    }
}

codec! {
    pub struct ProjectileInteraction {
        pub r#waitForDataFrom: WaitForDataFrom,
        pub r#effects: Option<InteractionEffects>,
        pub r#horizontalSpeedMultiplier: f32,
        pub r#runTime: f32,
        pub r#cancelOnItemChange: bool,
        pub r#settings: Option<Dictionary<GameMode, InteractionSettings>>,
        pub r#rules: Option<InteractionRules>,
        pub r#tags: Option<Vec<u32>>,
        pub r#camera: Option<InteractionCameraSettings>,
        pub r#next: u32,
        pub r#failed: u32,
        pub r#configId: Option<String>,
    }
}

codec! {
    pub struct RemoveEntityInteraction {
        pub r#waitForDataFrom: WaitForDataFrom,
        pub r#effects: Option<InteractionEffects>,
        pub r#horizontalSpeedMultiplier: f32,
        pub r#runTime: f32,
        pub r#cancelOnItemChange: bool,
        pub r#settings: Option<Dictionary<GameMode, InteractionSettings>>,
        pub r#rules: Option<InteractionRules>,
        pub r#tags: Option<Vec<u32>>,
        pub r#camera: Option<InteractionCameraSettings>,
        pub r#next: u32,
        pub r#failed: u32,
        pub r#entityTarget: InteractionTarget,
    }
}

codec! {
    pub struct ResetCooldownInteraction {
        pub r#waitForDataFrom: WaitForDataFrom,
        pub r#effects: Option<InteractionEffects>,
        pub r#horizontalSpeedMultiplier: f32,
        pub r#runTime: f32,
        pub r#cancelOnItemChange: bool,
        pub r#settings: Option<Dictionary<GameMode, InteractionSettings>>,
        pub r#rules: Option<InteractionRules>,
        pub r#tags: Option<Vec<u32>>,
        pub r#camera: Option<InteractionCameraSettings>,
        pub r#next: u32,
        pub r#failed: u32,
        pub r#cooldown: Option<InteractionCooldown>,
    }
}

codec! {
    pub struct InteractionCooldown {
        pub r#cooldownId: Option<String>,
        pub r#cooldown: f32,
        pub r#clickBypass: bool,
        pub r#chargeTimes: Option<Vec<f32>>,
        pub r#skipCooldownReset: bool,
        pub r#interruptRecharge: bool,
    }
}

codec! {
    pub struct TriggerCooldownInteraction {
        pub r#waitForDataFrom: WaitForDataFrom,
        pub r#effects: Option<InteractionEffects>,
        pub r#horizontalSpeedMultiplier: f32,
        pub r#runTime: f32,
        pub r#cancelOnItemChange: bool,
        pub r#settings: Option<Dictionary<GameMode, InteractionSettings>>,
        pub r#rules: Option<InteractionRules>,
        pub r#tags: Option<Vec<u32>>,
        pub r#camera: Option<InteractionCameraSettings>,
        pub r#next: u32,
        pub r#failed: u32,
        pub r#cooldown: Option<InteractionCooldown>,
    }
}

codec! {
    pub struct CooldownConditionInteraction {
        pub r#waitForDataFrom: WaitForDataFrom,
        pub r#effects: Option<InteractionEffects>,
        pub r#horizontalSpeedMultiplier: f32,
        pub r#runTime: f32,
        pub r#cancelOnItemChange: bool,
        pub r#settings: Option<Dictionary<GameMode, InteractionSettings>>,
        pub r#rules: Option<InteractionRules>,
        pub r#tags: Option<Vec<u32>>,
        pub r#camera: Option<InteractionCameraSettings>,
        pub r#next: u32,
        pub r#failed: u32,
        pub r#cooldownId: Option<String>,
    }
}

codec! {
    pub struct ChainFlagInteraction {
        pub r#waitForDataFrom: WaitForDataFrom,
        pub r#effects: Option<InteractionEffects>,
        pub r#horizontalSpeedMultiplier: f32,
        pub r#runTime: f32,
        pub r#cancelOnItemChange: bool,
        pub r#settings: Option<Dictionary<GameMode, InteractionSettings>>,
        pub r#rules: Option<InteractionRules>,
        pub r#tags: Option<Vec<u32>>,
        pub r#camera: Option<InteractionCameraSettings>,
        pub r#next: u32,
        pub r#failed: u32,
        pub r#chainId: Option<String>,
        pub r#flag: Option<String>,
    }
}

codec! {
    pub struct IncrementCooldownInteraction {
        pub r#waitForDataFrom: WaitForDataFrom,
        pub r#effects: Option<InteractionEffects>,
        pub r#horizontalSpeedMultiplier: f32,
        pub r#runTime: f32,
        pub r#cancelOnItemChange: bool,
        pub r#settings: Option<Dictionary<GameMode, InteractionSettings>>,
        pub r#rules: Option<InteractionRules>,
        pub r#tags: Option<Vec<u32>>,
        pub r#camera: Option<InteractionCameraSettings>,
        pub r#next: u32,
        pub r#failed: u32,
        pub r#cooldownId: Option<String>,
        pub r#cooldownIncrementTime: f32,
        pub r#cooldownIncrementCharge: u32,
        pub r#cooldownIncrementChargeTime: f32,
        pub r#cooldownIncrementInterrupt: bool,
    }
}

codec! {
    pub struct CancelChainInteraction {
        pub r#waitForDataFrom: WaitForDataFrom,
        pub r#effects: Option<InteractionEffects>,
        pub r#horizontalSpeedMultiplier: f32,
        pub r#runTime: f32,
        pub r#cancelOnItemChange: bool,
        pub r#settings: Option<Dictionary<GameMode, InteractionSettings>>,
        pub r#rules: Option<InteractionRules>,
        pub r#tags: Option<Vec<u32>>,
        pub r#camera: Option<InteractionCameraSettings>,
        pub r#next: u32,
        pub r#failed: u32,
        pub r#chainId: Option<String>,
    }
}

codec! {
    pub struct RunRootInteraction {
        pub r#waitForDataFrom: WaitForDataFrom,
        pub r#effects: Option<InteractionEffects>,
        pub r#horizontalSpeedMultiplier: f32,
        pub r#runTime: f32,
        pub r#cancelOnItemChange: bool,
        pub r#settings: Option<Dictionary<GameMode, InteractionSettings>>,
        pub r#rules: Option<InteractionRules>,
        pub r#tags: Option<Vec<u32>>,
        pub r#camera: Option<InteractionCameraSettings>,
        pub r#next: u32,
        pub r#failed: u32,
        pub r#rootInteraction: u32,
    }
}

codec! {
    pub struct CameraInteraction {
        pub r#waitForDataFrom: WaitForDataFrom,
        pub r#effects: Option<InteractionEffects>,
        pub r#horizontalSpeedMultiplier: f32,
        pub r#runTime: f32,
        pub r#cancelOnItemChange: bool,
        pub r#settings: Option<Dictionary<GameMode, InteractionSettings>>,
        pub r#rules: Option<InteractionRules>,
        pub r#tags: Option<Vec<u32>>,
        pub r#camera: Option<InteractionCameraSettings>,
        pub r#next: u32,
        pub r#failed: u32,
        pub r#cameraAction: CameraActionType,
        pub r#cameraPerspective: CameraPerspectiveType,
        pub r#cameraPersist: bool,
        pub r#cameraInteractionTime: f32,
    }
}

codec! {
    pub enum CameraActionType {
        r#ForcePerspective,
        r#Orbit,
        r#Transition,
    }
}

codec! {
    pub enum CameraPerspectiveType {
        r#First,
        r#Third,
    }
}

codec! {
    pub struct SpawnDeployableFromRaycastInteraction {
        pub r#waitForDataFrom: WaitForDataFrom,
        pub r#effects: Option<InteractionEffects>,
        pub r#horizontalSpeedMultiplier: f32,
        pub r#runTime: f32,
        pub r#cancelOnItemChange: bool,
        pub r#settings: Option<Dictionary<GameMode, InteractionSettings>>,
        pub r#rules: Option<InteractionRules>,
        pub r#tags: Option<Vec<u32>>,
        pub r#camera: Option<InteractionCameraSettings>,
        pub r#next: u32,
        pub r#failed: u32,
        pub r#deployableConfig: Option<DeployableConfig>,
        pub r#maxDistance: f32,
        pub r#costs: Option<Dictionary<u32, f32>>,
    }
}

codec! {
    pub struct DeployableConfig {
        pub r#model: Option<Model>,
        pub r#modelPreview: Option<Model>,
        pub r#allowPlaceOnWalls: bool,
    }
}

codec! {
    pub struct Model {
        pub r#assetId: Option<String>,
        pub r#path: Option<String>,
        pub r#texture: Option<String>,
        pub r#gradientSet: Option<String>,
        pub r#gradientId: Option<String>,
        pub r#camera: Option<CameraSettings>,
        pub r#scale: f32,
        pub r#eyeHeight: f32,
        pub r#crouchOffset: f32,
        pub r#animationSets: Option<Dictionary<String, AnimationSet>>,
        pub r#attachments: Option<Vec<ModelAttachment>>,
        pub r#hitbox: Option<Hitbox>,
        pub r#particles: Option<Vec<ModelParticle>>,
        pub r#trails: Option<Vec<ModelTrail>>,
        pub r#light: Option<ColorLight>,
        pub r#detailBoxes: Option<Dictionary<String, Vec<DetailBox>>>,
        pub r#phobia: Phobia,
        pub r#phobiaModel: Option<Box<Model>>,
    }
}

codec! {
    pub struct ModelAttachment {
        pub r#model: Option<String>,
        pub r#texture: Option<String>,
        pub r#gradientSet: Option<String>,
        pub r#gradientId: Option<String>,
    }
}

codec! {
    pub struct DetailBox {
        pub r#offset: Option<Vector3f>,
        pub r#box: Option<Hitbox>,
    }
}

codec! {
    pub enum Phobia {
        r#None,
        r#Arachnophobia,
        r#Ophidiophobia,
    }
}

codec! {
    pub struct MemoriesConditionInteraction {
        pub r#waitForDataFrom: WaitForDataFrom,
        pub r#effects: Option<InteractionEffects>,
        pub r#horizontalSpeedMultiplier: f32,
        pub r#runTime: f32,
        pub r#cancelOnItemChange: bool,
        pub r#settings: Option<Dictionary<GameMode, InteractionSettings>>,
        pub r#rules: Option<InteractionRules>,
        pub r#tags: Option<Vec<u32>>,
        pub r#camera: Option<InteractionCameraSettings>,
        pub r#memoriesNext: Option<Dictionary<u32, u32>>,
        pub r#failed: u32,
    }
}

codec! {
    pub struct ToggleGliderInteraction {
        pub r#waitForDataFrom: WaitForDataFrom,
        pub r#effects: Option<InteractionEffects>,
        pub r#horizontalSpeedMultiplier: f32,
        pub r#runTime: f32,
        pub r#cancelOnItemChange: bool,
        pub r#settings: Option<Dictionary<GameMode, InteractionSettings>>,
        pub r#rules: Option<InteractionRules>,
        pub r#tags: Option<Vec<u32>>,
        pub r#camera: Option<InteractionCameraSettings>,
        pub r#next: u32,
        pub r#failed: u32,
    }
}

codec! {
    pub struct UpdateRootInteractions {
        pub r#type: UpdateType,
        pub r#maxId: u32,
        pub r#interactions: Option<Dictionary<u32, RootInteraction>>,
    }
}

impl Packet for UpdateRootInteractions {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "UpdateRootInteractions",
        id: 67,
        is_compressed: true,
        max_size: 1677721600,
        category: PacketCategory::ASSETS,
    };
}

codec! {
    pub struct RootInteraction {
        pub r#id: Option<String>,
        pub r#interactions: Option<Vec<u32>>,
        pub r#cooldown: Option<InteractionCooldown>,
        pub r#settings: Option<Dictionary<GameMode, RootInteractionSettings>>,
        pub r#rules: Option<InteractionRules>,
        pub r#tags: Option<Vec<u32>>,
        pub r#clickQueuingTimeout: f32,
        pub r#requireNewClick: bool,
    }
}

codec! {
    pub struct RootInteractionSettings {
        pub r#allowSkipChainOnClick: bool,
        pub r#cooldown: Option<InteractionCooldown>,
    }
}

codec! {
    pub struct UpdateUnarmedInteractions {
        pub r#type: UpdateType,
        pub r#interactions: Option<Dictionary<InteractionType, u32>>,
    }
}

impl Packet for UpdateUnarmedInteractions {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "UpdateUnarmedInteractions",
        id: 68,
        is_compressed: true,
        max_size: 20480007,
        category: PacketCategory::ASSETS,
    };
}

codec! {
    pub struct TrackOrUpdateObjective {
        pub r#objective: Option<Objective>,
    }
}

impl Packet for TrackOrUpdateObjective {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "TrackOrUpdateObjective",
        id: 69,
        is_compressed: false,
        max_size: 1677721600,
        category: PacketCategory::ASSETS,
    };
}

codec! {
    pub struct Objective {
        pub r#objectiveUuid: Uuid,
        pub r#objectiveTitleKey: Option<String>,
        pub r#objectiveDescriptionKey: Option<String>,
        pub r#objectiveLineId: Option<String>,
        pub r#tasks: Option<Vec<ObjectiveTask>>,
    }
}

codec! {
    pub struct ObjectiveTask {
        pub r#taskDescriptionKey: Option<String>,
        pub r#currentCompletion: u32,
        pub r#completionNeeded: u32,
    }
}

codec! {
    pub struct UntrackObjective {
        pub r#objectiveUuid: Uuid,
    }
}

impl Packet for UntrackObjective {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "UntrackObjective",
        id: 70,
        is_compressed: false,
        max_size: 16,
        category: PacketCategory::ASSETS,
    };
}

codec! {
    pub struct UpdateObjectiveTask {
        pub r#objectiveUuid: Uuid,
        pub r#taskIndex: u32,
        pub r#task: Option<ObjectiveTask>,
    }
}

impl Packet for UpdateObjectiveTask {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "UpdateObjectiveTask",
        id: 71,
        is_compressed: false,
        max_size: 16384035,
        category: PacketCategory::ASSETS,
    };
}

codec! {
    pub struct UpdateEntityStatTypes {
        pub r#type: UpdateType,
        pub r#maxId: u32,
        pub r#types: Option<Dictionary<u32, EntityStatType>>,
    }
}

impl Packet for UpdateEntityStatTypes {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "UpdateEntityStatTypes",
        id: 72,
        is_compressed: true,
        max_size: 1677721600,
        category: PacketCategory::ASSETS,
    };
}

codec! {
    pub struct EntityStatType {
        pub r#id: Option<String>,
        pub r#value: f32,
        pub r#min: f32,
        pub r#max: f32,
        pub r#minValueEffects: Option<EntityStatEffects>,
        pub r#maxValueEffects: Option<EntityStatEffects>,
        pub r#resetBehavior: EntityStatResetBehavior,
    }
}

codec! {
    pub struct EntityStatEffects {
        pub r#triggerAtZero: bool,
        pub r#soundEventIndex: u32,
        pub r#particles: Option<Vec<ModelParticle>>,
    }
}

codec! {
    pub enum EntityStatResetBehavior {
        r#InitialValue,
        r#MaxValue,
    }
}

codec! {
    pub struct UpdateEntityUIComponents {
        pub r#type: UpdateType,
        pub r#maxId: u32,
        pub r#components: Option<Dictionary<u32, EntityUIComponent>>,
    }
}

impl Packet for UpdateEntityUIComponents {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "UpdateEntityUIComponents",
        id: 73,
        is_compressed: true,
        max_size: 1677721600,
        category: PacketCategory::ASSETS,
    };
}

codec! {
    pub struct EntityUIComponent {
        pub r#type: EntityUIType,
        pub r#hitboxOffset: Option<Vector2f>,
        pub r#unknown: bool,
        pub r#entityStatIndex: u32,
        pub r#combatTextRandomPositionOffsetRange: Option<RangeVector2f>,
        pub r#combatTextViewportMargin: f32,
        pub r#combatTextDuration: f32,
        pub r#combatTextHitAngleModifierStrength: f32,
        pub r#combatTextFontSize: f32,
        pub r#combatTextColor: Option<Color>,
        pub r#combatTextAnimationEvents: Option<Vec<CombatTextEntityUIComponentAnimationEvent>>,
    }
}

codec! {
    pub enum EntityUIType {
        r#EntityStat,
        r#CombatText,
    }
}

codec! {
    pub struct CombatTextEntityUIComponentAnimationEvent {
        pub r#type: CombatTextEntityUIAnimationEventType,
        pub r#startAt: f32,
        pub r#endAt: f32,
        pub r#startScale: f32,
        pub r#endScale: f32,
        pub r#positionOffset: Option<Vector2f>,
        pub r#startOpacity: f32,
        pub r#endOpacity: f32,
    }
}

codec! {
    pub enum CombatTextEntityUIAnimationEventType {
        r#Scale,
        r#Position,
        r#Opacity,
    }
}

codec! {
    pub struct UpdateHitboxCollisionConfig {
        pub r#type: UpdateType,
        pub r#maxId: u32,
        pub r#hitboxCollisionConfigs: Option<Dictionary<u32, HitboxCollisionConfig>>,
    }
}

impl Packet for UpdateHitboxCollisionConfig {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "UpdateHitboxCollisionConfig",
        id: 74,
        is_compressed: true,
        max_size: 36864011,
        category: PacketCategory::ASSETS,
    };
}

codec! {
    pub struct HitboxCollisionConfig {
        pub r#collisionType: CollisionType,
        pub r#softCollisionOffsetRatio: f32,
    }
}

codec! {
    pub enum CollisionType {
        r#Hard,
        r#Soft,
    }
}

codec! {
    pub struct UpdateRepulsionConfig {
        pub r#type: UpdateType,
        pub r#maxId: u32,
        pub r#repulsionConfigs: Option<Dictionary<u32, RepulsionConfig>>,
    }
}

impl Packet for UpdateRepulsionConfig {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "UpdateRepulsionConfig",
        id: 75,
        is_compressed: true,
        max_size: 65536011,
        category: PacketCategory::ASSETS,
    };
}

codec! {
    pub struct RepulsionConfig {
        pub r#radius: f32,
        pub r#minForce: f32,
        pub r#maxForce: f32,
    }
}

codec! {
    pub struct UpdateViewBobbing {
        pub r#type: UpdateType,
        pub r#profiles: Option<Dictionary<MovementType, ViewBobbing>>,
    }
}

impl Packet for UpdateViewBobbing {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "UpdateViewBobbing",
        id: 76,
        is_compressed: true,
        max_size: 1677721600,
        category: PacketCategory::ASSETS,
    };
}

codec! {
    pub enum MovementType {
        r#None,
        r#Idle,
        r#Crouching,
        r#Walking,
        r#Running,
        r#Sprinting,
        r#Climbing,
        r#Swimming,
        r#Flying,
        r#Sliding,
        r#Rolling,
        r#Mounting,
        r#SprintMounting,
    }
}

codec! {
    pub struct ViewBobbing {
        pub r#firstPerson: Option<CameraShakeConfig>,
    }
}

codec! {
    pub struct CameraShakeConfig {
        pub r#duration: f32,
        pub r#startTime: f32,
        pub r#continuous: bool,
        pub r#easeIn: Option<EasingConfig>,
        pub r#easeOut: Option<EasingConfig>,
        pub r#offset: Option<OffsetNoise>,
        pub r#rotation: Option<RotationNoise>,
    }
}

codec! {
    pub struct EasingConfig {
        @small = true;
        pub r#time: f32,
        pub r#type: EasingType,
    }
}

codec! {
    pub enum EasingType {
        r#Linear,
        r#QuadIn,
        r#QuadOut,
        r#QuadInOut,
        r#CubicIn,
        r#CubicOut,
        r#CubicInOut,
        r#QuartIn,
        r#QuartOut,
        r#QuartInOut,
        r#QuintIn,
        r#QuintOut,
        r#QuintInOut,
        r#SineIn,
        r#SineOut,
        r#SineInOut,
        r#ExpoIn,
        r#ExpoOut,
        r#ExpoInOut,
        r#CircIn,
        r#CircOut,
        r#CircInOut,
        r#ElasticIn,
        r#ElasticOut,
        r#ElasticInOut,
        r#BackIn,
        r#BackOut,
        r#BackInOut,
        r#BounceIn,
        r#BounceOut,
        r#BounceInOut,
    }
}

codec! {
    pub struct OffsetNoise {
        pub r#x: Option<Vec<NoiseConfig>>,
        pub r#y: Option<Vec<NoiseConfig>>,
        pub r#z: Option<Vec<NoiseConfig>>,
    }
}

codec! {
    pub struct NoiseConfig {
        pub r#seed: u32,
        pub r#type: NoiseType,
        pub r#frequency: f32,
        pub r#amplitude: f32,
        pub r#clamp: Option<ClampConfig>,
    }
}

codec! {
    pub enum NoiseType {
        r#Sin,
        r#Cos,
        r#Perlin_Linear,
        r#Perlin_Hermite,
        r#Perlin_Quintic,
        r#Random,
    }
}

codec! {
    pub struct ClampConfig {
        @small = true;
        pub r#min: f32,
        pub r#max: f32,
        pub r#normalize: bool,
    }
}

codec! {
    pub struct RotationNoise {
        pub r#pitch: Option<Vec<NoiseConfig>>,
        pub r#yaw: Option<Vec<NoiseConfig>>,
        pub r#roll: Option<Vec<NoiseConfig>>,
    }
}

codec! {
    pub struct UpdateCameraShake {
        pub r#type: UpdateType,
        pub r#profiles: Option<Dictionary<u32, CameraShake>>,
    }
}

impl Packet for UpdateCameraShake {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "UpdateCameraShake",
        id: 77,
        is_compressed: true,
        max_size: 1677721600,
        category: PacketCategory::ASSETS,
    };
}

codec! {
    pub struct CameraShake {
        pub r#firstPerson: Option<CameraShakeConfig>,
        pub r#thirdPerson: Option<CameraShakeConfig>,
    }
}

codec! {
    pub struct UpdateBlockGroups {
        pub r#type: UpdateType,
        pub r#groups: Option<Dictionary<String, BlockGroup>>,
    }
}

impl Packet for UpdateBlockGroups {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "UpdateBlockGroups",
        id: 78,
        is_compressed: true,
        max_size: 1677721600,
        category: PacketCategory::ASSETS,
    };
}

codec! {
    pub struct BlockGroup {
        pub r#names: Option<Vec<String>>,
    }
}

codec! {
    pub struct UpdateSoundSets {
        pub r#type: UpdateType,
        pub r#maxId: u32,
        pub r#soundSets: Option<Dictionary<u32, SoundSet>>,
    }
}

impl Packet for UpdateSoundSets {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "UpdateSoundSets",
        id: 79,
        is_compressed: true,
        max_size: 1677721600,
        category: PacketCategory::ASSETS,
    };
}

codec! {
    pub struct SoundSet {
        pub r#id: Option<String>,
        pub r#sounds: Option<Dictionary<String, u32>>,
        pub r#category: SoundCategory,
    }
}

codec! {
    pub enum SoundCategory {
        r#Music,
        r#Ambient,
        r#SFX,
        r#UI,
    }
}

codec! {
    pub struct UpdateAudioCategories {
        pub r#type: UpdateType,
        pub r#maxId: u32,
        pub r#categories: Option<Dictionary<u32, AudioCategory>>,
    }
}

impl Packet for UpdateAudioCategories {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "UpdateAudioCategories",
        id: 80,
        is_compressed: true,
        max_size: 1677721600,
        category: PacketCategory::ASSETS,
    };
}

codec! {
    pub struct AudioCategory {
        pub r#id: Option<String>,
        pub r#volume: f32,
    }
}

codec! {
    pub struct UpdateReverbEffects {
        pub r#type: UpdateType,
        pub r#maxId: u32,
        pub r#effects: Option<Dictionary<u32, ReverbEffect>>,
    }
}

impl Packet for UpdateReverbEffects {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "UpdateReverbEffects",
        id: 81,
        is_compressed: true,
        max_size: 1677721600,
        category: PacketCategory::ASSETS,
    };
}

codec! {
    pub struct ReverbEffect {
        pub r#id: Option<String>,
        pub r#dryGain: f32,
        pub r#modalDensity: f32,
        pub r#diffusion: f32,
        pub r#gain: f32,
        pub r#highFrequencyGain: f32,
        pub r#decayTime: f32,
        pub r#highFrequencyDecayRatio: f32,
        pub r#reflectionGain: f32,
        pub r#reflectionDelay: f32,
        pub r#lateReverbGain: f32,
        pub r#lateReverbDelay: f32,
        pub r#roomRolloffFactor: f32,
        pub r#airAbsorptionHighFrequencyGain: f32,
        pub r#limitDecayHighFrequency: bool,
    }
}

codec! {
    pub struct UpdateEqualizerEffects {
        pub r#type: UpdateType,
        pub r#maxId: u32,
        pub r#effects: Option<Dictionary<u32, EqualizerEffect>>,
    }
}

impl Packet for UpdateEqualizerEffects {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "UpdateEqualizerEffects",
        id: 82,
        is_compressed: true,
        max_size: 1677721600,
        category: PacketCategory::ASSETS,
    };
}

codec! {
    pub struct EqualizerEffect {
        pub r#id: Option<String>,
        pub r#lowGain: f32,
        pub r#lowCutOff: f32,
        pub r#lowMidGain: f32,
        pub r#lowMidCenter: f32,
        pub r#lowMidWidth: f32,
        pub r#highMidGain: f32,
        pub r#highMidCenter: f32,
        pub r#highMidWidth: f32,
        pub r#highGain: f32,
        pub r#highCutOff: f32,
    }
}

codec! {
    pub struct UpdateFluids {
        pub r#type: UpdateType,
        pub r#maxId: u32,
        pub r#fluids: Option<Dictionary<u32, Fluid>>,
    }
}

impl Packet for UpdateFluids {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "UpdateFluids",
        id: 83,
        is_compressed: true,
        max_size: 1677721600,
        category: PacketCategory::ASSETS,
    };
}

codec! {
    pub struct Fluid {
        pub r#id: Option<String>,
        pub r#maxFluidLevel: u32,
        pub r#cubeTextures: Option<Vec<BlockTextures>>,
        pub r#requiresAlphaBlending: bool,
        pub r#opacity: Opacity,
        pub r#shaderEffect: Option<Vec<ShaderType>>,
        pub r#light: Option<ColorLight>,
        pub r#fluidFXIndex: u32,
        pub r#blockSoundSetIndex: u32,
        pub r#blockParticleSetId: Option<String>,
        pub r#particleColor: Option<Color>,
        pub r#tagIndexes: Option<Vec<u32>>,
    }
}

codec! {
    pub struct UpdateTagPatterns {
        pub r#type: UpdateType,
        pub r#maxId: u32,
        pub r#patterns: Option<Dictionary<u32, TagPattern>>,
    }
}

impl Packet for UpdateTagPatterns {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "UpdateTagPatterns",
        id: 84,
        is_compressed: true,
        max_size: 1677721600,
        category: PacketCategory::ASSETS,
    };
}

codec! {
    pub struct TagPattern {
        pub r#type: TagPatternType,
        pub r#tagIndex: u32,
        pub r#operands: Option<Vec<TagPattern>>,
        pub r#not: Option<Box<TagPattern>>,
    }
}

codec! {
    pub enum TagPatternType {
        r#Equals,
        r#And,
        r#Or,
        r#Not,
    }
}

codec! {
    pub struct UpdateProjectileConfigs {
        pub r#type: UpdateType,
        pub r#configs: Option<Dictionary<String, ProjectileConfig>>,
        pub r#removedConfigs: Option<Vec<String>>,
    }
}

impl Packet for UpdateProjectileConfigs {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "UpdateProjectileConfigs",
        id: 85,
        is_compressed: true,
        max_size: 1677721600,
        category: PacketCategory::ASSETS,
    };
}

codec! {
    pub struct ProjectileConfig {
        pub r#physicsConfig: Option<PhysicsConfig>,
        pub r#model: Option<Model>,
        pub r#launchForce: f64,
        pub r#spawnOffset: Option<Vector3f>,
        pub r#rotationOffset: Option<Direction>,
        pub r#interactions: Option<Dictionary<InteractionType, u32>>,
        pub r#launchLocalSoundEventIndex: u32,
        pub r#projectileSoundEventIndex: u32,
    }
}

codec! {
    pub struct PhysicsConfig {
        @small = true;
        pub r#type: PhysicsType,
        pub r#density: f64,
        pub r#gravity: f64,
        pub r#bounciness: f64,
        pub r#bounceCount: u32,
        pub r#bounceLimit: f64,
        pub r#sticksVertically: bool,
        pub r#computeYaw: bool,
        pub r#computePitch: bool,
        pub r#rotationMode: RotationMode,
        pub r#moveOutOfSolidSpeed: f64,
        pub r#terminalVelocityAir: f64,
        pub r#densityAir: f64,
        pub r#terminalVelocityWater: f64,
        pub r#densityWater: f64,
        pub r#hitWaterImpulseLoss: f64,
        pub r#rotationForce: f64,
        pub r#speedRotationFactor: f32,
        pub r#swimmingDampingFactor: f64,
        pub r#allowRolling: bool,
        pub r#rollingFrictionFactor: f64,
        pub r#rollingSpeed: f32,
    }
}

codec! {
    pub enum PhysicsType {
        r#Standard,
    }
}

codec! {
    pub enum RotationMode {
        r#None,
        r#Velocity,
        r#VelocityDamped,
        r#VelocityRoll,
    }
}

codec! {
    pub struct SetClientId {
        pub r#clientId: u32,
    }
}

impl Packet for SetClientId {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "SetClientId",
        id: 100,
        is_compressed: false,
        max_size: 4,
        category: PacketCategory::PLAYER,
    };
}

codec! {
    pub struct SetGameMode {
        pub r#gameMode: GameMode,
    }
}

impl Packet for SetGameMode {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "SetGameMode",
        id: 101,
        is_compressed: false,
        max_size: 1,
        category: PacketCategory::PLAYER,
    };
}

codec! {
    pub struct SetMovementStates {
        pub r#movementStates: Option<SavedMovementStates>,
    }
}

impl Packet for SetMovementStates {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "SetMovementStates",
        id: 102,
        is_compressed: false,
        max_size: 2,
        category: PacketCategory::PLAYER,
    };
}

codec! {
    pub struct SavedMovementStates {
        @small = true;
        pub r#flying: bool,
    }
}

codec! {
    pub struct SetBlockPlacementOverride {
        pub r#enabled: bool,
    }
}

impl Packet for SetBlockPlacementOverride {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "SetBlockPlacementOverride",
        id: 103,
        is_compressed: false,
        max_size: 1,
        category: PacketCategory::PLAYER,
    };
}

codec! {
    pub struct JoinWorld {
        pub r#clearWorld: bool,
        pub r#fadeInOut: bool,
        pub r#worldUuid: Uuid,
    }
}

impl Packet for JoinWorld {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "JoinWorld",
        id: 104,
        is_compressed: false,
        max_size: 18,
        category: PacketCategory::PLAYER,
    };
}

codec! {
    pub struct ClientReady {
        pub r#readyForChunks: bool,
        pub r#readyForGameplay: bool,
    }
}

impl Packet for ClientReady {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "ClientReady",
        id: 105,
        is_compressed: false,
        max_size: 2,
        category: PacketCategory::PLAYER,
    };
}

codec! {
    pub struct LoadHotbar {
        pub r#inventoryRow: u8,
    }
}

impl Packet for LoadHotbar {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "LoadHotbar",
        id: 106,
        is_compressed: false,
        max_size: 1,
        category: PacketCategory::PLAYER,
    };
}

codec! {
    pub struct SaveHotbar {
        pub r#inventoryRow: u8,
    }
}

impl Packet for SaveHotbar {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "SaveHotbar",
        id: 107,
        is_compressed: false,
        max_size: 1,
        category: PacketCategory::PLAYER,
    };
}

codec! {
    pub struct ClientMovement {
        pub r#movementStates: Option<MovementStates>,
        pub r#relativePosition: Option<HalfFloatPosition>,
        pub r#absolutePosition: Option<Position>,
        pub r#bodyOrientation: Option<Direction>,
        pub r#lookOrientation: Option<Direction>,
        pub r#teleportAck: Option<TeleportAck>,
        pub r#wishMovement: Option<Position>,
        pub r#velocity: Option<Vector3d>,
        pub r#mountedTo: u32,
        pub r#riderMovementStates: Option<MovementStates>,
    }
}

impl Packet for ClientMovement {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "ClientMovement",
        id: 108,
        is_compressed: false,
        max_size: 153,
        category: PacketCategory::PLAYER,
    };
}

codec! {
    pub struct MovementStates {
        @small = true;
        pub r#idle: bool,
        pub r#horizontalIdle: bool,
        pub r#jumping: bool,
        pub r#flying: bool,
        pub r#walking: bool,
        pub r#running: bool,
        pub r#sprinting: bool,
        pub r#crouching: bool,
        pub r#forcedCrouching: bool,
        pub r#falling: bool,
        pub r#climbing: bool,
        pub r#inFluid: bool,
        pub r#swimming: bool,
        pub r#swimJumping: bool,
        pub r#onGround: bool,
        pub r#mantling: bool,
        pub r#sliding: bool,
        pub r#mounting: bool,
        pub r#rolling: bool,
        pub r#sitting: bool,
        pub r#gliding: bool,
        pub r#sleeping: bool,
    }
}

codec! {
    pub struct HalfFloatPosition {
        @small = true;
        pub r#x: u16,
        pub r#y: u16,
        pub r#z: u16,
    }
}

codec! {
    pub struct Position {
        @small = true;
        pub r#x: f64,
        pub r#y: f64,
        pub r#z: f64,
    }
}

codec! {
    pub struct TeleportAck {
        @small = true;
        pub r#teleportId: u8,
    }
}

codec! {
    pub struct Vector3d {
        @small = true;
        pub r#x: f64,
        pub r#y: f64,
        pub r#z: f64,
    }
}

codec! {
    pub struct ClientTeleport {
        pub r#teleportId: u8,
        pub r#modelTransform: Option<ModelTransform>,
        pub r#resetVelocity: bool,
    }
}

impl Packet for ClientTeleport {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "ClientTeleport",
        id: 109,
        is_compressed: false,
        max_size: 52,
        category: PacketCategory::PLAYER,
    };
}

codec! {
    pub struct ModelTransform {
        @small = true;
        pub r#position: Option<Position>,
        pub r#bodyOrientation: Option<Direction>,
        pub r#lookOrientation: Option<Direction>,
    }
}

codec! {
    pub struct UpdateMovementSettings {
        pub r#movementSettings: Option<MovementSettings>,
    }
}

impl Packet for UpdateMovementSettings {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "UpdateMovementSettings",
        id: 110,
        is_compressed: false,
        max_size: 252,
        category: PacketCategory::PLAYER,
    };
}

codec! {
    pub struct MovementSettings {
        @small = true;
        pub r#mass: f32,
        pub r#dragCoefficient: f32,
        pub r#invertedGravity: bool,
        pub r#velocityResistance: f32,
        pub r#jumpForce: f32,
        pub r#swimJumpForce: f32,
        pub r#jumpBufferDuration: f32,
        pub r#jumpBufferMaxYVelocity: f32,
        pub r#acceleration: f32,
        pub r#airDragMin: f32,
        pub r#airDragMax: f32,
        pub r#airDragMinSpeed: f32,
        pub r#airDragMaxSpeed: f32,
        pub r#airFrictionMin: f32,
        pub r#airFrictionMax: f32,
        pub r#airFrictionMinSpeed: f32,
        pub r#airFrictionMaxSpeed: f32,
        pub r#airSpeedMultiplier: f32,
        pub r#airControlMinSpeed: f32,
        pub r#airControlMaxSpeed: f32,
        pub r#airControlMinMultiplier: f32,
        pub r#airControlMaxMultiplier: f32,
        pub r#comboAirSpeedMultiplier: f32,
        pub r#baseSpeed: f32,
        pub r#climbSpeed: f32,
        pub r#climbSpeedLateral: f32,
        pub r#climbUpSprintSpeed: f32,
        pub r#climbDownSprintSpeed: f32,
        pub r#horizontalFlySpeed: f32,
        pub r#verticalFlySpeed: f32,
        pub r#maxSpeedMultiplier: f32,
        pub r#minSpeedMultiplier: f32,
        pub r#wishDirectionGravityX: f32,
        pub r#wishDirectionGravityY: f32,
        pub r#wishDirectionWeightX: f32,
        pub r#wishDirectionWeightY: f32,
        pub r#canFly: bool,
        pub r#collisionExpulsionForce: f32,
        pub r#forwardWalkSpeedMultiplier: f32,
        pub r#backwardWalkSpeedMultiplier: f32,
        pub r#strafeWalkSpeedMultiplier: f32,
        pub r#forwardRunSpeedMultiplier: f32,
        pub r#backwardRunSpeedMultiplier: f32,
        pub r#strafeRunSpeedMultiplier: f32,
        pub r#forwardCrouchSpeedMultiplier: f32,
        pub r#backwardCrouchSpeedMultiplier: f32,
        pub r#strafeCrouchSpeedMultiplier: f32,
        pub r#forwardSprintSpeedMultiplier: f32,
        pub r#variableJumpFallForce: f32,
        pub r#fallEffectDuration: f32,
        pub r#fallJumpForce: f32,
        pub r#fallMomentumLoss: f32,
        pub r#autoJumpObstacleSpeedLoss: f32,
        pub r#autoJumpObstacleSprintSpeedLoss: f32,
        pub r#autoJumpObstacleEffectDuration: f32,
        pub r#autoJumpObstacleSprintEffectDuration: f32,
        pub r#autoJumpObstacleMaxAngle: f32,
        pub r#autoJumpDisableJumping: bool,
        pub r#minSlideEntrySpeed: f32,
        pub r#slideExitSpeed: f32,
        pub r#minFallSpeedToEngageRoll: f32,
        pub r#maxFallSpeedToEngageRoll: f32,
        pub r#rollStartSpeedModifier: f32,
        pub r#rollExitSpeedModifier: f32,
        pub r#rollTimeToComplete: f32,
    }
}

codec! {
    pub struct MouseInteraction {
        pub r#clientTimestamp: u64,
        pub r#activeSlot: u32,
        pub r#itemInHandId: Option<String>,
        pub r#screenPoint: Option<Vector2f>,
        pub r#mouseButton: Option<MouseButtonEvent>,
        pub r#mouseMotion: Option<MouseMotionEvent>,
        pub r#worldInteraction: Option<WorldInteraction>,
    }
}

impl Packet for MouseInteraction {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "MouseInteraction",
        id: 111,
        is_compressed: false,
        max_size: 20480071,
        category: PacketCategory::PLAYER,
    };
}

codec! {
    pub struct MouseButtonEvent {
        @small = true;
        pub r#mouseButtonType: MouseButtonType,
        pub r#state: MouseButtonState,
        pub r#clicks: u8,
    }
}

codec! {
    pub enum MouseButtonType {
        r#Left,
        r#Middle,
        r#Right,
        r#X1,
        r#X2,
    }
}

codec! {
    pub enum MouseButtonState {
        r#Pressed,
        r#Released,
    }
}

codec! {
    pub struct MouseMotionEvent {
        pub r#mouseButtonType: Option<Vec<MouseButtonType>>,
        pub r#relativeMotion: Option<Vector2i>,
    }
}

codec! {
    pub struct WorldInteraction {
        @small = true;
        pub r#entityId: u32,
        pub r#blockPosition: Option<BlockPosition>,
        pub r#blockRotation: Option<BlockRotation>,
    }
}

codec! {
    pub struct BlockPosition {
        @small = true;
        pub r#x: u32,
        pub r#y: u32,
        pub r#z: u32,
    }
}

codec! {
    pub struct BlockRotation {
        @small = true;
        pub r#rotationYaw: Rotation,
        pub r#rotationPitch: Rotation,
        pub r#rotationRoll: Rotation,
    }
}

codec! {
    pub struct DamageInfo {
        pub r#damageSourcePosition: Option<Vector3d>,
        pub r#damageAmount: f32,
        pub r#damageCause: Option<DamageCause>,
    }
}

impl Packet for DamageInfo {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "DamageInfo",
        id: 112,
        is_compressed: false,
        max_size: 32768048,
        category: PacketCategory::PLAYER,
    };
}

codec! {
    pub struct DamageCause {
        pub r#id: Option<String>,
        pub r#damageTextColor: Option<String>,
    }
}

codec! {
    pub struct ReticleEvent {
        pub r#eventIndex: u32,
    }
}

impl Packet for ReticleEvent {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "ReticleEvent",
        id: 113,
        is_compressed: false,
        max_size: 4,
        category: PacketCategory::PLAYER,
    };
}

codec! {
    pub struct DisplayDebug {
        pub r#shape: DebugShape,
        pub r#matrix: Option<Vec<f32>>,
        pub r#color: Option<Vector3f>,
        pub r#time: f32,
        pub r#fade: bool,
        pub r#frustumProjection: Option<Vec<f32>>,
    }
}

impl Packet for DisplayDebug {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "DisplayDebug",
        id: 114,
        is_compressed: false,
        max_size: 32768037,
        category: PacketCategory::PLAYER,
    };
}

codec! {
    pub enum DebugShape {
        r#Sphere,
        r#Cylinder,
        r#Cone,
        r#Cube,
        r#Frustum,
    }
}

codec! {
    pub struct ClearDebugShapes {
    }
}

impl Packet for ClearDebugShapes {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "ClearDebugShapes",
        id: 115,
        is_compressed: false,
        max_size: 0,
        category: PacketCategory::PLAYER,
    };
}

codec! {
    pub struct SyncPlayerPreferences {
        pub r#showEntityMarkers: bool,
        pub r#armorItemsPreferredPickupLocation: PickupLocation,
        pub r#weaponAndToolItemsPreferredPickupLocation: PickupLocation,
        pub r#usableItemsItemsPreferredPickupLocation: PickupLocation,
        pub r#solidBlockItemsPreferredPickupLocation: PickupLocation,
        pub r#miscItemsPreferredPickupLocation: PickupLocation,
        pub r#allowNPCDetection: bool,
        pub r#respondToHit: bool,
        pub r#hideHelmet: bool,
        pub r#hideCuirass: bool,
        pub r#hideGauntlets: bool,
        pub r#hidePants: bool,
    }
}

impl Packet for SyncPlayerPreferences {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "SyncPlayerPreferences",
        id: 116,
        is_compressed: false,
        max_size: 12,
        category: PacketCategory::PLAYER,
    };
}

codec! {
    pub enum PickupLocation {
        r#Hotbar,
        r#Storage,
    }
}

codec! {
    pub struct ClientPlaceBlock {
        pub r#position: Option<BlockPosition>,
        pub r#rotation: Option<BlockRotation>,
        pub r#placedBlockId: u32,
    }
}

impl Packet for ClientPlaceBlock {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "ClientPlaceBlock",
        id: 117,
        is_compressed: false,
        max_size: 20,
        category: PacketCategory::PLAYER,
    };
}

codec! {
    pub struct UpdateMemoriesFeatureStatus {
        pub r#isFeatureUnlocked: bool,
    }
}

impl Packet for UpdateMemoriesFeatureStatus {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "UpdateMemoriesFeatureStatus",
        id: 118,
        is_compressed: false,
        max_size: 1,
        category: PacketCategory::PLAYER,
    };
}

codec! {
    pub struct RemoveMapMarker {
        pub r#markerId: Option<String>,
    }
}

impl Packet for RemoveMapMarker {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "RemoveMapMarker",
        id: 119,
        is_compressed: false,
        max_size: 16384006,
        category: PacketCategory::PLAYER,
    };
}

codec! {
    pub struct SetChunk {
        pub r#x: u32,
        pub r#y: u32,
        pub r#z: u32,
        pub r#localLight: Option<Vec<u8>>,
        pub r#globalLight: Option<Vec<u8>>,
        pub r#data: Option<Vec<u8>>,
    }
}

impl Packet for SetChunk {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "SetChunk",
        id: 131,
        is_compressed: true,
        max_size: 12288040,
        category: PacketCategory::WORLD,
    };
}

codec! {
    pub struct SetChunkHeightmap {
        pub r#x: u32,
        pub r#z: u32,
        pub r#heightmap: Option<Vec<u8>>,
    }
}

impl Packet for SetChunkHeightmap {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "SetChunkHeightmap",
        id: 132,
        is_compressed: true,
        max_size: 4096014,
        category: PacketCategory::WORLD,
    };
}

codec! {
    pub struct SetChunkTintmap {
        pub r#x: u32,
        pub r#z: u32,
        pub r#tintmap: Option<Vec<u8>>,
    }
}

impl Packet for SetChunkTintmap {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "SetChunkTintmap",
        id: 133,
        is_compressed: true,
        max_size: 4096014,
        category: PacketCategory::WORLD,
    };
}

codec! {
    pub struct SetChunkEnvironments {
        pub r#x: u32,
        pub r#z: u32,
        pub r#environments: Option<Vec<u8>>,
    }
}

impl Packet for SetChunkEnvironments {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "SetChunkEnvironments",
        id: 134,
        is_compressed: true,
        max_size: 4096014,
        category: PacketCategory::WORLD,
    };
}

codec! {
    pub struct UnloadChunk {
        pub r#chunkX: u32,
        pub r#chunkZ: u32,
    }
}

impl Packet for UnloadChunk {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "UnloadChunk",
        id: 135,
        is_compressed: false,
        max_size: 8,
        category: PacketCategory::WORLD,
    };
}

codec! {
    pub struct SetFluids {
        pub r#x: u32,
        pub r#y: u32,
        pub r#z: u32,
        pub r#data: Option<Vec<u8>>,
    }
}

impl Packet for SetFluids {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "SetFluids",
        id: 136,
        is_compressed: true,
        max_size: 4096018,
        category: PacketCategory::WORLD,
    };
}

codec! {
    pub struct ServerSetBlock {
        pub r#x: u32,
        pub r#y: u32,
        pub r#z: u32,
        pub r#blockId: u32,
        pub r#filler: u16,
        pub r#rotation: u8,
    }
}

impl Packet for ServerSetBlock {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "ServerSetBlock",
        id: 140,
        is_compressed: false,
        max_size: 19,
        category: PacketCategory::WORLD,
    };
}

codec! {
    pub struct ServerSetBlocks {
        pub r#x: u32,
        pub r#y: u32,
        pub r#z: u32,
        pub r#cmds: Vec<SetBlockCmd>,
    }
}

impl Packet for ServerSetBlocks {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "ServerSetBlocks",
        id: 141,
        is_compressed: false,
        max_size: 36864017,
        category: PacketCategory::WORLD,
    };
}

codec! {
    pub struct SetBlockCmd {
        pub r#index: u16,
        pub r#blockId: u32,
        pub r#filler: u16,
        pub r#rotation: u8,
    }
}

codec! {
    pub struct ServerSetFluid {
        pub r#x: u32,
        pub r#y: u32,
        pub r#z: u32,
        pub r#fluidId: u32,
        pub r#fluidLevel: u8,
    }
}

impl Packet for ServerSetFluid {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "ServerSetFluid",
        id: 142,
        is_compressed: false,
        max_size: 17,
        category: PacketCategory::WORLD,
    };
}

codec! {
    pub struct ServerSetFluids {
        pub r#x: u32,
        pub r#y: u32,
        pub r#z: u32,
        pub r#cmds: Vec<SetFluidCmd>,
    }
}

impl Packet for ServerSetFluids {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "ServerSetFluids",
        id: 143,
        is_compressed: false,
        max_size: 28672017,
        category: PacketCategory::WORLD,
    };
}

codec! {
    pub struct SetFluidCmd {
        pub r#index: u16,
        pub r#fluidId: u32,
        pub r#fluidLevel: u8,
    }
}

codec! {
    pub struct UpdateBlockDamage {
        pub r#blockPosition: Option<BlockPosition>,
        pub r#damage: f32,
        pub r#delta: f32,
    }
}

impl Packet for UpdateBlockDamage {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "UpdateBlockDamage",
        id: 144,
        is_compressed: false,
        max_size: 21,
        category: PacketCategory::WORLD,
    };
}

codec! {
    pub struct UpdateTimeSettings {
        pub r#daytimeDurationSeconds: u32,
        pub r#nighttimeDurationSeconds: u32,
        pub r#totalMoonPhases: u8,
        pub r#timePaused: bool,
    }
}

impl Packet for UpdateTimeSettings {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "UpdateTimeSettings",
        id: 145,
        is_compressed: false,
        max_size: 10,
        category: PacketCategory::WORLD,
    };
}

codec! {
    pub struct UpdateTime {
        pub r#gameTime: Option<InstantData>,
    }
}

impl Packet for UpdateTime {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "UpdateTime",
        id: 146,
        is_compressed: false,
        max_size: 13,
        category: PacketCategory::WORLD,
    };
}

codec! {
    pub struct UpdateEditorTimeOverride {
        pub r#gameTime: Option<InstantData>,
        pub r#paused: bool,
    }
}

impl Packet for UpdateEditorTimeOverride {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "UpdateEditorTimeOverride",
        id: 147,
        is_compressed: false,
        max_size: 14,
        category: PacketCategory::WORLD,
    };
}

codec! {
    pub struct ClearEditorTimeOverride {
    }
}

impl Packet for ClearEditorTimeOverride {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "ClearEditorTimeOverride",
        id: 148,
        is_compressed: false,
        max_size: 0,
        category: PacketCategory::WORLD,
    };
}

codec! {
    pub struct UpdateWeather {
        pub r#weatherIndex: u32,
        pub r#transitionSeconds: f32,
    }
}

impl Packet for UpdateWeather {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "UpdateWeather",
        id: 149,
        is_compressed: false,
        max_size: 8,
        category: PacketCategory::WORLD,
    };
}

codec! {
    pub struct UpdateEditorWeatherOverride {
        pub r#weatherIndex: u32,
    }
}

impl Packet for UpdateEditorWeatherOverride {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "UpdateEditorWeatherOverride",
        id: 150,
        is_compressed: false,
        max_size: 4,
        category: PacketCategory::WORLD,
    };
}

codec! {
    pub struct UpdateEnvironmentMusic {
        pub r#environmentIndex: u32,
    }
}

impl Packet for UpdateEnvironmentMusic {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "UpdateEnvironmentMusic",
        id: 151,
        is_compressed: false,
        max_size: 4,
        category: PacketCategory::WORLD,
    };
}

codec! {
    pub struct SpawnParticleSystem {
        pub r#particleSystemId: Option<String>,
        pub r#position: Option<Position>,
        pub r#rotation: Option<Direction>,
        pub r#scale: f32,
        pub r#color: Option<Color>,
    }
}

impl Packet for SpawnParticleSystem {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "SpawnParticleSystem",
        id: 152,
        is_compressed: false,
        max_size: 16384049,
        category: PacketCategory::WORLD,
    };
}

codec! {
    pub struct SpawnBlockParticleSystem {
        pub r#blockId: u32,
        pub r#particleType: BlockParticleEvent,
        pub r#position: Option<Position>,
    }
}

impl Packet for SpawnBlockParticleSystem {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "SpawnBlockParticleSystem",
        id: 153,
        is_compressed: false,
        max_size: 30,
        category: PacketCategory::WORLD,
    };
}

codec! {
    pub struct PlaySoundEvent2D {
        pub r#soundEventIndex: u32,
        pub r#category: SoundCategory,
        pub r#volumeModifier: f32,
        pub r#pitchModifier: f32,
    }
}

impl Packet for PlaySoundEvent2D {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "PlaySoundEvent2D",
        id: 154,
        is_compressed: false,
        max_size: 13,
        category: PacketCategory::WORLD,
    };
}

codec! {
    pub struct PlaySoundEvent3D {
        pub r#soundEventIndex: u32,
        pub r#category: SoundCategory,
        pub r#position: Option<Position>,
        pub r#volumeModifier: f32,
        pub r#pitchModifier: f32,
    }
}

impl Packet for PlaySoundEvent3D {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "PlaySoundEvent3D",
        id: 155,
        is_compressed: false,
        max_size: 38,
        category: PacketCategory::WORLD,
    };
}

codec! {
    pub struct PlaySoundEventEntity {
        pub r#soundEventIndex: u32,
        pub r#networkId: u32,
        pub r#volumeModifier: f32,
        pub r#pitchModifier: f32,
    }
}

impl Packet for PlaySoundEventEntity {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "PlaySoundEventEntity",
        id: 156,
        is_compressed: false,
        max_size: 16,
        category: PacketCategory::WORLD,
    };
}

codec! {
    pub struct UpdateSleepState {
        pub r#grayFade: bool,
        pub r#sleepUi: bool,
        pub r#clock: Option<SleepClock>,
        pub r#multiplayer: Option<SleepMultiplayer>,
    }
}

impl Packet for UpdateSleepState {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "UpdateSleepState",
        id: 157,
        is_compressed: false,
        max_size: 65536050,
        category: PacketCategory::WORLD,
    };
}

codec! {
    pub struct SleepClock {
        @small = true;
        pub r#startGametime: Option<InstantData>,
        pub r#targetGametime: Option<InstantData>,
        pub r#progress: f32,
        pub r#durationSeconds: f32,
    }
}

codec! {
    pub struct SleepMultiplayer {
        pub r#sleepersCount: u32,
        pub r#awakeCount: u32,
        pub r#awakeSample: Option<Vec<Uuid>>,
    }
}

codec! {
    pub struct SetPaused {
        pub r#paused: bool,
    }
}

impl Packet for SetPaused {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "SetPaused",
        id: 158,
        is_compressed: false,
        max_size: 1,
        category: PacketCategory::WORLD,
    };
}

codec! {
    pub struct ServerSetPaused {
        pub r#paused: bool,
    }
}

impl Packet for ServerSetPaused {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "ServerSetPaused",
        id: 159,
        is_compressed: false,
        max_size: 1,
        category: PacketCategory::WORLD,
    };
}

codec! {
    pub struct SetEntitySeed {
        pub r#entitySeed: u32,
    }
}

impl Packet for SetEntitySeed {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "SetEntitySeed",
        id: 160,
        is_compressed: false,
        max_size: 4,
        category: PacketCategory::ENTITIES,
    };
}

codec! {
    pub struct EntityUpdates {
        pub r#removed: Option<Vec<u32>>,
        pub r#updates: Option<Vec<EntityUpdate>>,
    }
}

impl Packet for EntityUpdates {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "EntityUpdates",
        id: 161,
        is_compressed: true,
        max_size: 1677721600,
        category: PacketCategory::ENTITIES,
    };
}

codec! {
    pub struct EntityUpdate {
        pub r#networkId: u32,
        pub r#removed: Option<Vec<ComponentUpdateType>>,
        pub r#updates: Option<Vec<ComponentUpdate>>,
    }
}

codec! {
    pub enum ComponentUpdateType {
        r#Nameplate,
        r#UIComponents,
        r#CombatText,
        r#Model,
        r#PlayerSkin,
        r#Item,
        r#Block,
        r#Equipment,
        r#EntityStats,
        r#Transform,
        r#MovementStates,
        r#EntityEffects,
        r#Interactions,
        r#DynamicLight,
        r#Interactable,
        r#Intangible,
        r#Invulnerable,
        r#RespondToHit,
        r#HitboxCollision,
        r#Repulsion,
        r#Prediction,
        r#Audio,
        r#Mounted,
        r#NewSpawn,
        r#ActiveAnimations,
    }
}

codec! {
    pub struct ComponentUpdate {
        pub r#type: ComponentUpdateType,
        pub r#nameplate: Option<Nameplate>,
        pub r#entityUIComponents: Option<Vec<u32>>,
        pub r#combatTextUpdate: Option<CombatTextUpdate>,
        pub r#model: Option<Model>,
        pub r#skin: Option<PlayerSkin>,
        pub r#item: Option<ItemWithAllMetadata>,
        pub r#blockId: u32,
        pub r#entityScale: f32,
        pub r#equipment: Option<Equipment>,
        pub r#entityStatUpdates: Option<Dictionary<u32, Vec<EntityStatUpdate>>>,
        pub r#transform: Option<ModelTransform>,
        pub r#movementStates: Option<MovementStates>,
        pub r#entityEffectUpdates: Option<Vec<EntityEffectUpdate>>,
        pub r#interactions: Option<Dictionary<InteractionType, u32>>,
        pub r#dynamicLight: Option<ColorLight>,
        pub r#hitboxCollisionConfigIndex: u32,
        pub r#repulsionConfigIndex: u32,
        pub r#predictionId: Uuid,
        pub r#soundEventIds: Option<Vec<u32>>,
        pub r#interactionHint: Option<String>,
        pub r#mounted: Option<MountedUpdate>,
        pub r#activeAnimations: Option<Vec<String>>,
    }
}

codec! {
    pub struct Nameplate {
        pub r#text: Option<String>,
    }
}

codec! {
    pub struct CombatTextUpdate {
        pub r#hitAngleDeg: f32,
        pub r#text: Option<String>,
    }
}

codec! {
    pub struct Equipment {
        pub r#armorIds: Option<Vec<String>>,
        pub r#rightHandItemId: Option<String>,
        pub r#leftHandItemId: Option<String>,
    }
}

codec! {
    pub struct EntityStatUpdate {
        pub r#op: EntityStatOp,
        pub r#predictable: bool,
        pub r#value: f32,
        pub r#modifiers: Option<Dictionary<String, Modifier>>,
        pub r#modifierKey: Option<String>,
        pub r#modifier: Option<Modifier>,
    }
}

codec! {
    pub enum EntityStatOp {
        r#Init,
        r#Remove,
        r#PutModifier,
        r#RemoveModifier,
        r#Add,
        r#Set,
        r#Minimize,
        r#Maximize,
        r#Reset,
    }
}

codec! {
    pub struct EntityEffectUpdate {
        pub r#type: EffectOp,
        pub r#id: u32,
        pub r#remainingTime: f32,
        pub r#infinite: bool,
        pub r#debuff: bool,
        pub r#statusEffectIcon: Option<String>,
    }
}

codec! {
    pub enum EffectOp {
        r#Add,
        r#Remove,
    }
}

codec! {
    pub struct MountedUpdate {
        @small = true;
        pub r#mountedToEntity: u32,
        pub r#attachmentOffset: Option<Vector3f>,
        pub r#controller: MountController,
        pub r#block: Option<BlockMount>,
    }
}

codec! {
    pub enum MountController {
        r#Minecart,
        r#BlockMount,
    }
}

codec! {
    pub struct BlockMount {
        @small = true;
        pub r#type: BlockMountType,
        pub r#position: Option<Vector3f>,
        pub r#orientation: Option<Vector3f>,
        pub r#blockTypeId: u32,
    }
}

codec! {
    pub enum BlockMountType {
        r#Seat,
        r#Bed,
    }
}

codec! {
    pub struct PlayAnimation {
        pub r#entityId: u32,
        pub r#itemAnimationsId: Option<String>,
        pub r#animationId: Option<String>,
        pub r#slot: AnimationSlot,
    }
}

impl Packet for PlayAnimation {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "PlayAnimation",
        id: 162,
        is_compressed: false,
        max_size: 32768024,
        category: PacketCategory::ENTITIES,
    };
}

codec! {
    pub enum AnimationSlot {
        r#Movement,
        r#Status,
        r#Action,
        r#Face,
        r#Emote,
    }
}

codec! {
    pub struct ChangeVelocity {
        pub r#x: f32,
        pub r#y: f32,
        pub r#z: f32,
        pub r#changeType: ChangeVelocityType,
        pub r#config: Option<VelocityConfig>,
    }
}

impl Packet for ChangeVelocity {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "ChangeVelocity",
        id: 163,
        is_compressed: false,
        max_size: 35,
        category: PacketCategory::ENTITIES,
    };
}

codec! {
    pub struct ApplyKnockback {
        pub r#hitPosition: Option<Position>,
        pub r#x: f32,
        pub r#y: f32,
        pub r#z: f32,
        pub r#changeType: ChangeVelocityType,
    }
}

impl Packet for ApplyKnockback {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "ApplyKnockback",
        id: 164,
        is_compressed: false,
        max_size: 38,
        category: PacketCategory::ENTITIES,
    };
}

codec! {
    pub struct SpawnModelParticles {
        pub r#entityId: u32,
        pub r#modelParticles: Option<Vec<ModelParticle>>,
    }
}

impl Packet for SpawnModelParticles {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "SpawnModelParticles",
        id: 165,
        is_compressed: false,
        max_size: 1677721600,
        category: PacketCategory::ENTITIES,
    };
}

codec! {
    pub struct MountMovement {
        pub r#absolutePosition: Option<Position>,
        pub r#bodyOrientation: Option<Direction>,
        pub r#movementStates: Option<MovementStates>,
    }
}

impl Packet for MountMovement {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "MountMovement",
        id: 166,
        is_compressed: false,
        max_size: 59,
        category: PacketCategory::ENTITIES,
    };
}

codec! {
    pub struct UpdatePlayerInventory {
        pub r#storage: Option<InventorySection>,
        pub r#armor: Option<InventorySection>,
        pub r#hotbar: Option<InventorySection>,
        pub r#utility: Option<InventorySection>,
        pub r#builderMaterial: Option<InventorySection>,
        pub r#tools: Option<InventorySection>,
        pub r#backpack: Option<InventorySection>,
        pub r#sortType: SortType,
    }
}

impl Packet for UpdatePlayerInventory {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "UpdatePlayerInventory",
        id: 170,
        is_compressed: true,
        max_size: 1677721600,
        category: PacketCategory::INVENTORY,
    };
}

codec! {
    pub struct InventorySection {
        pub r#items: Option<Dictionary<u32, ItemWithAllMetadata>>,
        pub r#capacity: u16,
    }
}

codec! {
    pub enum SortType {
        r#Name,
        r#Type,
        r#Rarity,
    }
}

codec! {
    pub struct SetCreativeItem {
        pub r#inventorySectionId: u32,
        pub r#slotId: u32,
        pub r#item: ItemQuantity,
        pub r#override: bool,
    }
}

impl Packet for SetCreativeItem {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "SetCreativeItem",
        id: 171,
        is_compressed: false,
        max_size: 16384019,
        category: PacketCategory::INVENTORY,
    };
}

codec! {
    pub struct ItemQuantity {
        pub r#itemId: Option<String>,
        pub r#quantity: u32,
    }
}

codec! {
    pub struct DropCreativeItem {
        pub r#item: ItemQuantity,
    }
}

impl Packet for DropCreativeItem {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "DropCreativeItem",
        id: 172,
        is_compressed: false,
        max_size: 16384010,
        category: PacketCategory::INVENTORY,
    };
}

codec! {
    pub struct SmartGiveCreativeItem {
        pub r#item: ItemQuantity,
        pub r#moveType: SmartMoveType,
    }
}

impl Packet for SmartGiveCreativeItem {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "SmartGiveCreativeItem",
        id: 173,
        is_compressed: false,
        max_size: 16384011,
        category: PacketCategory::INVENTORY,
    };
}

codec! {
    pub enum SmartMoveType {
        r#EquipOrMergeStack,
        r#PutInHotbarOrWindow,
        r#PutInHotbarOrBackpack,
    }
}

codec! {
    pub struct DropItemStack {
        pub r#inventorySectionId: u32,
        pub r#slotId: u32,
        pub r#quantity: u32,
    }
}

impl Packet for DropItemStack {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "DropItemStack",
        id: 174,
        is_compressed: false,
        max_size: 12,
        category: PacketCategory::INVENTORY,
    };
}

codec! {
    pub struct MoveItemStack {
        pub r#fromSectionId: u32,
        pub r#fromSlotId: u32,
        pub r#quantity: u32,
        pub r#toSectionId: u32,
        pub r#toSlotId: u32,
    }
}

impl Packet for MoveItemStack {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "MoveItemStack",
        id: 175,
        is_compressed: false,
        max_size: 20,
        category: PacketCategory::INVENTORY,
    };
}

codec! {
    pub struct SmartMoveItemStack {
        pub r#fromSectionId: u32,
        pub r#fromSlotId: u32,
        pub r#quantity: u32,
        pub r#moveType: SmartMoveType,
    }
}

impl Packet for SmartMoveItemStack {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "SmartMoveItemStack",
        id: 176,
        is_compressed: false,
        max_size: 13,
        category: PacketCategory::INVENTORY,
    };
}

codec! {
    pub struct SetActiveSlot {
        pub r#inventorySectionId: u32,
        pub r#activeSlot: u32,
    }
}

impl Packet for SetActiveSlot {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "SetActiveSlot",
        id: 177,
        is_compressed: false,
        max_size: 8,
        category: PacketCategory::INVENTORY,
    };
}

codec! {
    pub struct SwitchHotbarBlockSet {
        pub r#itemId: Option<String>,
    }
}

impl Packet for SwitchHotbarBlockSet {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "SwitchHotbarBlockSet",
        id: 178,
        is_compressed: false,
        max_size: 16384006,
        category: PacketCategory::INVENTORY,
    };
}

codec! {
    pub struct InventoryAction {
        pub r#inventorySectionId: u32,
        pub r#inventoryActionType: InventoryActionType,
        pub r#actionData: u8,
    }
}

impl Packet for InventoryAction {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "InventoryAction",
        id: 179,
        is_compressed: false,
        max_size: 6,
        category: PacketCategory::INVENTORY,
    };
}

codec! {
    pub enum InventoryActionType {
        r#TakeAll,
        r#PutAll,
        r#QuickStack,
        r#Sort,
    }
}

codec! {
    pub struct OpenWindow {
        pub r#id: u32,
        pub r#windowType: WindowType,
        pub r#windowData: Option<String>,
        pub r#inventory: Option<InventorySection>,
        pub r#extraResources: Option<ExtraResources>,
    }
}

impl Packet for OpenWindow {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "OpenWindow",
        id: 200,
        is_compressed: true,
        max_size: 1677721600,
        category: PacketCategory::WINDOW,
    };
}

codec! {
    pub enum WindowType {
        r#Container,
        r#PocketCrafting,
        r#BasicCrafting,
        r#DiagramCrafting,
        r#StructuralCrafting,
        r#Processing,
        r#Memories,
    }
}

codec! {
    pub struct ExtraResources {
        pub r#resources: Option<Vec<ItemQuantity>>,
    }
}

codec! {
    pub struct UpdateWindow {
        pub r#id: u32,
        pub r#windowData: Option<String>,
        pub r#inventory: Option<InventorySection>,
        pub r#extraResources: Option<ExtraResources>,
    }
}

impl Packet for UpdateWindow {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "UpdateWindow",
        id: 201,
        is_compressed: true,
        max_size: 1677721600,
        category: PacketCategory::WINDOW,
    };
}

codec! {
    pub struct CloseWindow {
        pub r#id: u32,
    }
}

impl Packet for CloseWindow {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "CloseWindow",
        id: 202,
        is_compressed: false,
        max_size: 4,
        category: PacketCategory::WINDOW,
    };
}

codec! {
    pub struct SendWindowAction {
        pub r#id: u32,
        pub r#action: WindowAction,
    }
}

impl Packet for SendWindowAction {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "SendWindowAction",
        id: 203,
        is_compressed: false,
        max_size: 32768027,
        category: PacketCategory::WINDOW,
    };
}

codec! {
    pub union WindowAction {
        CraftRecipeAction(CraftRecipeAction),
        TierUpgradeAction(TierUpgradeAction),
        SelectSlotAction(SelectSlotAction),
        ChangeBlockAction(ChangeBlockAction),
        SetActiveAction(SetActiveAction),
        CraftItemAction(CraftItemAction),
        UpdateCategoryAction(UpdateCategoryAction),
        CancelCraftingAction(CancelCraftingAction),
        SortItemsAction(SortItemsAction),
    }
}

codec! {
    pub struct CraftRecipeAction {
        pub r#recipeId: Option<String>,
        pub r#quantity: u32,
    }
}

codec! {
    pub struct TierUpgradeAction {
    }
}

codec! {
    pub struct SelectSlotAction {
        pub r#slot: u32,
    }
}

codec! {
    pub struct ChangeBlockAction {
        pub r#down: bool,
    }
}

codec! {
    pub struct SetActiveAction {
        pub r#state: bool,
    }
}

codec! {
    pub struct CraftItemAction {
    }
}

codec! {
    pub struct UpdateCategoryAction {
        pub r#category: String,
        pub r#itemCategory: String,
    }
}

codec! {
    pub struct CancelCraftingAction {
    }
}

codec! {
    pub struct SortItemsAction {
        pub r#sortType: SortType,
    }
}

codec! {
    pub struct ClientOpenWindow {
        pub r#type: WindowType,
    }
}

impl Packet for ClientOpenWindow {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "ClientOpenWindow",
        id: 204,
        is_compressed: false,
        max_size: 1,
        category: PacketCategory::WINDOW,
    };
}

codec! {
    pub struct ServerMessage {
        pub r#type: ChatType,
        pub r#message: Option<FormattedMessage>,
    }
}

impl Packet for ServerMessage {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "ServerMessage",
        id: 210,
        is_compressed: false,
        max_size: 1677721600,
        category: PacketCategory::INTERFACE,
    };
}

codec! {
    pub enum ChatType {
        r#Chat,
    }
}

codec! {
    pub struct FormattedMessage {
        pub r#rawText: Option<String>,
        pub r#messageId: Option<String>,
        pub r#children: Option<Vec<FormattedMessage>>,
        pub r#params: Option<Dictionary<String, ParamValue>>,
        pub r#messageParams: Option<Dictionary<String, FormattedMessage>>,
        pub r#color: Option<String>,
        pub r#bold: MaybeBool,
        pub r#italic: MaybeBool,
        pub r#monospace: MaybeBool,
        pub r#underlined: MaybeBool,
        pub r#link: Option<String>,
        pub r#markupEnabled: bool,
    }
}

codec! {
    pub union ParamValue {
        StringParamValue(StringParamValue),
        BoolParamValue(BoolParamValue),
        DoubleParamValue(DoubleParamValue),
        IntParamValue(IntParamValue),
        LongParamValue(LongParamValue),
    }
}

codec! {
    pub struct StringParamValue {
        pub r#value: Option<String>,
    }
}

codec! {
    pub struct BoolParamValue {
        pub r#value: bool,
    }
}

codec! {
    pub struct DoubleParamValue {
        pub r#value: f64,
    }
}

codec! {
    pub struct IntParamValue {
        pub r#value: u32,
    }
}

codec! {
    pub struct LongParamValue {
        pub r#value: u64,
    }
}

codec! {
    pub enum MaybeBool {
        r#Null,
        r#False,
        r#True,
    }
}

codec! {
    pub struct ChatMessage {
        pub r#message: Option<String>,
    }
}

impl Packet for ChatMessage {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "ChatMessage",
        id: 211,
        is_compressed: false,
        max_size: 16384006,
        category: PacketCategory::INTERFACE,
    };
}

codec! {
    pub struct Notification {
        pub r#message: Option<FormattedMessage>,
        pub r#secondaryMessage: Option<FormattedMessage>,
        pub r#icon: Option<String>,
        pub r#item: Option<ItemWithAllMetadata>,
        pub r#style: NotificationStyle,
    }
}

impl Packet for Notification {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "Notification",
        id: 212,
        is_compressed: false,
        max_size: 1677721600,
        category: PacketCategory::INTERFACE,
    };
}

codec! {
    pub enum NotificationStyle {
        r#Default,
        r#Danger,
        r#Warning,
        r#Success,
    }
}

codec! {
    pub struct KillFeedMessage {
        pub r#killer: Option<FormattedMessage>,
        pub r#decedent: Option<FormattedMessage>,
        pub r#icon: Option<String>,
    }
}

impl Packet for KillFeedMessage {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "KillFeedMessage",
        id: 213,
        is_compressed: false,
        max_size: 1677721600,
        category: PacketCategory::INTERFACE,
    };
}

codec! {
    pub struct ShowEventTitle {
        pub r#fadeInDuration: f32,
        pub r#fadeOutDuration: f32,
        pub r#duration: f32,
        pub r#icon: Option<String>,
        pub r#isMajor: bool,
        pub r#primaryTitle: Option<FormattedMessage>,
        pub r#secondaryTitle: Option<FormattedMessage>,
    }
}

impl Packet for ShowEventTitle {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "ShowEventTitle",
        id: 214,
        is_compressed: false,
        max_size: 1677721600,
        category: PacketCategory::INTERFACE,
    };
}

codec! {
    pub struct HideEventTitle {
        pub r#fadeOutDuration: f32,
    }
}

impl Packet for HideEventTitle {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "HideEventTitle",
        id: 215,
        is_compressed: false,
        max_size: 4,
        category: PacketCategory::INTERFACE,
    };
}

codec! {
    pub struct SetPage {
        pub r#page: Page,
        pub r#canCloseThroughInteraction: bool,
    }
}

impl Packet for SetPage {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "SetPage",
        id: 216,
        is_compressed: false,
        max_size: 2,
        category: PacketCategory::INTERFACE,
    };
}

codec! {
    pub enum Page {
        r#None,
        r#Bench,
        r#Inventory,
        r#ToolsSettings,
        r#Map,
        r#MachinimaEditor,
        r#ContentCreation,
        r#Custom,
    }
}

codec! {
    pub struct CustomHud {
        pub r#clear: bool,
        pub r#commands: Option<Vec<CustomUICommand>>,
    }
}

impl Packet for CustomHud {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "CustomHud",
        id: 217,
        is_compressed: true,
        max_size: 1677721600,
        category: PacketCategory::INTERFACE,
    };
}

codec! {
    pub struct CustomUICommand {
        pub r#type: CustomUICommandType,
        pub r#selector: Option<String>,
        pub r#data: Option<String>,
        pub r#text: Option<String>,
    }
}

codec! {
    pub enum CustomUICommandType {
        r#Append,
        r#AppendInline,
        r#InsertBefore,
        r#InsertBeforeInline,
        r#Remove,
        r#Set,
        r#Clear,
    }
}

codec! {
    pub struct CustomPage {
        pub r#key: Option<String>,
        pub r#isInitial: bool,
        pub r#clear: bool,
        pub r#lifetime: CustomPageLifetime,
        pub r#commands: Option<Vec<CustomUICommand>>,
        pub r#eventBindings: Option<Vec<CustomUIEventBinding>>,
    }
}

impl Packet for CustomPage {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "CustomPage",
        id: 218,
        is_compressed: true,
        max_size: 1677721600,
        category: PacketCategory::INTERFACE,
    };
}

codec! {
    pub enum CustomPageLifetime {
        r#CantClose,
        r#CanDismiss,
        r#CanDismissOrCloseThroughInteraction,
    }
}

codec! {
    pub struct CustomUIEventBinding {
        pub r#type: CustomUIEventBindingType,
        pub r#selector: Option<String>,
        pub r#data: Option<String>,
        pub r#locksInterface: bool,
    }
}

codec! {
    pub enum CustomUIEventBindingType {
        r#Activating,
        r#RightClicking,
        r#DoubleClicking,
        r#MouseEntered,
        r#MouseExited,
        r#ValueChanged,
        r#ElementReordered,
        r#Validating,
        r#Dismissing,
        r#FocusGained,
        r#FocusLost,
        r#KeyDown,
        r#MouseButtonReleased,
        r#SlotClicking,
        r#SlotDoubleClicking,
        r#SlotMouseEntered,
        r#SlotMouseExited,
        r#DragCancelled,
        r#Dropped,
        r#SlotMouseDragCompleted,
        r#SlotMouseDragExited,
        r#SlotClickReleaseWhileDragging,
        r#SlotClickPressWhileDragging,
        r#SelectedTabChanged,
    }
}

codec! {
    pub struct CustomPageEvent {
        pub r#type: CustomPageEventType,
        pub r#data: Option<String>,
    }
}

impl Packet for CustomPageEvent {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "CustomPageEvent",
        id: 219,
        is_compressed: false,
        max_size: 16384007,
        category: PacketCategory::INTERFACE,
    };
}

codec! {
    pub enum CustomPageEventType {
        r#Acknowledge,
        r#Data,
        r#Dismiss,
    }
}

codec! {
    pub struct EditorBlocksChange {
        pub r#selection: Option<EditorSelection>,
        pub r#blocksChange: Option<Vec<BlockChange>>,
        pub r#fluidsChange: Option<Vec<FluidChange>>,
        pub r#blocksCount: u32,
        pub r#advancedPreview: bool,
    }
}

impl Packet for EditorBlocksChange {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "EditorBlocksChange",
        id: 222,
        is_compressed: true,
        max_size: 139264048,
        category: PacketCategory::INTERFACE,
    };
}

codec! {
    pub struct EditorSelection {
        @small = true;
        pub r#minX: u32,
        pub r#minY: u32,
        pub r#minZ: u32,
        pub r#maxX: u32,
        pub r#maxY: u32,
        pub r#maxZ: u32,
    }
}

codec! {
    pub struct BlockChange {
        pub r#x: u32,
        pub r#y: u32,
        pub r#z: u32,
        pub r#block: u32,
        pub r#rotation: u8,
    }
}

codec! {
    pub struct FluidChange {
        pub r#x: u32,
        pub r#y: u32,
        pub r#z: u32,
        pub r#fluidId: u32,
        pub r#fluidLevel: u8,
    }
}

codec! {
    pub struct ServerInfo {
        pub r#serverName: Option<String>,
        pub r#motd: Option<String>,
        pub r#maxPlayers: u32,
    }
}

impl Packet for ServerInfo {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "ServerInfo",
        id: 223,
        is_compressed: false,
        max_size: 32768023,
        category: PacketCategory::INTERFACE,
    };
}

codec! {
    pub struct AddToServerPlayerList {
        pub r#players: Option<Vec<ServerPlayerListPlayer>>,
    }
}

impl Packet for AddToServerPlayerList {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "AddToServerPlayerList",
        id: 224,
        is_compressed: false,
        max_size: 1677721600,
        category: PacketCategory::INTERFACE,
    };
}

codec! {
    pub struct ServerPlayerListPlayer {
        pub r#uuid: Uuid,
        pub r#username: Option<String>,
        pub r#worldUuid: Option<Uuid>,
        pub r#ping: u32,
    }
}

codec! {
    pub struct RemoveFromServerPlayerList {
        pub r#players: Option<Vec<Uuid>>,
    }
}

impl Packet for RemoveFromServerPlayerList {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "RemoveFromServerPlayerList",
        id: 225,
        is_compressed: false,
        max_size: 65536006,
        category: PacketCategory::INTERFACE,
    };
}

codec! {
    pub struct UpdateServerPlayerList {
        pub r#players: Option<Vec<ServerPlayerListUpdate>>,
    }
}

impl Packet for UpdateServerPlayerList {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "UpdateServerPlayerList",
        id: 226,
        is_compressed: false,
        max_size: 131072006,
        category: PacketCategory::INTERFACE,
    };
}

codec! {
    pub struct ServerPlayerListUpdate {
        pub r#uuid: Uuid,
        pub r#worldUuid: Uuid,
    }
}

codec! {
    pub struct UpdateServerPlayerListPing {
        pub r#players: Option<Dictionary<Uuid, u32>>,
    }
}

impl Packet for UpdateServerPlayerListPing {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "UpdateServerPlayerListPing",
        id: 227,
        is_compressed: false,
        max_size: 81920006,
        category: PacketCategory::INTERFACE,
    };
}

codec! {
    pub struct UpdateKnownRecipes {
        pub r#known: Option<Dictionary<String, CraftingRecipe>>,
    }
}

impl Packet for UpdateKnownRecipes {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "UpdateKnownRecipes",
        id: 228,
        is_compressed: false,
        max_size: 1677721600,
        category: PacketCategory::INTERFACE,
    };
}

codec! {
    pub struct UpdatePortal {
        pub r#state: Option<PortalState>,
        pub r#definition: Option<PortalDef>,
    }
}

impl Packet for UpdatePortal {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "UpdatePortal",
        id: 229,
        is_compressed: false,
        max_size: 16384020,
        category: PacketCategory::INTERFACE,
    };
}

codec! {
    pub struct PortalState {
        @small = true;
        pub r#remainingSeconds: u32,
        pub r#breaching: bool,
    }
}

codec! {
    pub struct PortalDef {
        pub r#nameKey: Option<String>,
        pub r#explorationSeconds: u32,
        pub r#breachSeconds: u32,
    }
}

codec! {
    pub struct UpdateVisibleHudComponents {
        pub r#visibleComponents: Option<Vec<HudComponent>>,
    }
}

impl Packet for UpdateVisibleHudComponents {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "UpdateVisibleHudComponents",
        id: 230,
        is_compressed: false,
        max_size: 4096006,
        category: PacketCategory::INTERFACE,
    };
}

codec! {
    pub enum HudComponent {
        r#Hotbar,
        r#StatusIcons,
        r#Reticle,
        r#Chat,
        r#Requests,
        r#Notifications,
        r#KillFeed,
        r#InputBindings,
        r#PlayerList,
        r#EventTitle,
        r#Compass,
        r#ObjectivePanel,
        r#PortalPanel,
        r#BuilderToolsLegend,
        r#Speedometer,
        r#UtilitySlotSelector,
        r#BlockVariantSelector,
        r#BuilderToolsMaterialSlotSelector,
        r#Stamina,
        r#AmmoIndicator,
        r#Health,
        r#Mana,
        r#Oxygen,
        r#Sleep,
    }
}

codec! {
    pub struct ResetUserInterfaceState {
    }
}

impl Packet for ResetUserInterfaceState {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "ResetUserInterfaceState",
        id: 231,
        is_compressed: false,
        max_size: 0,
        category: PacketCategory::INTERFACE,
    };
}

codec! {
    pub struct UpdateLanguage {
        pub r#language: Option<String>,
    }
}

impl Packet for UpdateLanguage {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "UpdateLanguage",
        id: 232,
        is_compressed: false,
        max_size: 16384006,
        category: PacketCategory::INTERFACE,
    };
}

codec! {
    pub struct WorldSavingStatus {
        pub r#isWorldSaving: bool,
    }
}

impl Packet for WorldSavingStatus {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "WorldSavingStatus",
        id: 233,
        is_compressed: false,
        max_size: 1,
        category: PacketCategory::INTERFACE,
    };
}

codec! {
    pub struct OpenChatWithCommand {
        pub r#command: Option<String>,
    }
}

impl Packet for OpenChatWithCommand {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "OpenChatWithCommand",
        id: 234,
        is_compressed: false,
        max_size: 16384006,
        category: PacketCategory::INTERFACE,
    };
}

codec! {
    pub struct UpdateWorldMapSettings {
        pub r#enabled: bool,
        pub r#biomeDataMap: Option<Dictionary<u16, BiomeData>>,
        pub r#allowTeleportToCoordinates: bool,
        pub r#allowTeleportToMarkers: bool,
        pub r#defaultScale: f32,
        pub r#minScale: f32,
        pub r#maxScale: f32,
    }
}

impl Packet for UpdateWorldMapSettings {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "UpdateWorldMapSettings",
        id: 240,
        is_compressed: false,
        max_size: 1677721600,
        category: PacketCategory::WORLD_MAP,
    };
}

codec! {
    pub struct BiomeData {
        pub r#zoneId: u32,
        pub r#zoneName: Option<String>,
        pub r#biomeName: Option<String>,
        pub r#biomeColor: u32,
    }
}

codec! {
    pub struct UpdateWorldMap {
        pub r#chunks: Option<Vec<MapChunk>>,
        pub r#addedMarkers: Option<Vec<MapMarker>>,
        pub r#removedMarkers: Option<Vec<String>>,
    }
}

impl Packet for UpdateWorldMap {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "UpdateWorldMap",
        id: 241,
        is_compressed: true,
        max_size: 1677721600,
        category: PacketCategory::WORLD_MAP,
    };
}

codec! {
    pub struct MapChunk {
        pub r#chunkX: u32,
        pub r#chunkZ: u32,
        pub r#image: Option<MapImage>,
    }
}

codec! {
    pub struct MapImage {
        pub r#width: u32,
        pub r#height: u32,
        pub r#data: Option<Vec<u32>>,
    }
}

codec! {
    pub struct MapMarker {
        pub r#id: Option<String>,
        pub r#name: Option<String>,
        pub r#markerImage: Option<String>,
        pub r#transform: Option<Transform>,
        pub r#contextMenuItems: Option<Vec<ContextMenuItem>>,
    }
}

codec! {
    pub struct Transform {
        @small = true;
        pub r#position: Option<Position>,
        pub r#orientation: Option<Direction>,
    }
}

codec! {
    pub struct ContextMenuItem {
        pub r#name: String,
        pub r#command: String,
    }
}

codec! {
    pub struct ClearWorldMap {
    }
}

impl Packet for ClearWorldMap {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "ClearWorldMap",
        id: 242,
        is_compressed: false,
        max_size: 0,
        category: PacketCategory::WORLD_MAP,
    };
}

codec! {
    pub struct UpdateWorldMapVisible {
        pub r#visible: bool,
    }
}

impl Packet for UpdateWorldMapVisible {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "UpdateWorldMapVisible",
        id: 243,
        is_compressed: false,
        max_size: 1,
        category: PacketCategory::WORLD_MAP,
    };
}

codec! {
    pub struct TeleportToWorldMapMarker {
        pub r#id: Option<String>,
    }
}

impl Packet for TeleportToWorldMapMarker {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "TeleportToWorldMapMarker",
        id: 244,
        is_compressed: false,
        max_size: 16384006,
        category: PacketCategory::WORLD_MAP,
    };
}

codec! {
    pub struct TeleportToWorldMapPosition {
        pub r#x: u32,
        pub r#y: u32,
    }
}

impl Packet for TeleportToWorldMapPosition {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "TeleportToWorldMapPosition",
        id: 245,
        is_compressed: false,
        max_size: 8,
        category: PacketCategory::WORLD_MAP,
    };
}

codec! {
    pub struct RequestServerAccess {
        pub r#access: Access,
        pub r#externalPort: u16,
    }
}

impl Packet for RequestServerAccess {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "RequestServerAccess",
        id: 250,
        is_compressed: false,
        max_size: 3,
        category: PacketCategory::SERVER_ACCESS,
    };
}

codec! {
    pub enum Access {
        r#Private,
        r#LAN,
        r#Friend,
        r#Open,
    }
}

codec! {
    pub struct UpdateServerAccess {
        pub r#access: Access,
        pub r#hosts: Option<Vec<HostAddress>>,
    }
}

impl Packet for UpdateServerAccess {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "UpdateServerAccess",
        id: 251,
        is_compressed: false,
        max_size: 1677721600,
        category: PacketCategory::SERVER_ACCESS,
    };
}

codec! {
    pub struct SetServerAccess {
        pub r#access: Access,
        pub r#password: Option<String>,
    }
}

impl Packet for SetServerAccess {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "SetServerAccess",
        id: 252,
        is_compressed: false,
        max_size: 16384007,
        category: PacketCategory::SERVER_ACCESS,
    };
}

codec! {
    pub struct RequestMachinimaActorModel {
        pub r#modelId: Option<String>,
        pub r#sceneName: Option<String>,
        pub r#actorName: Option<String>,
    }
}

impl Packet for RequestMachinimaActorModel {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "RequestMachinimaActorModel",
        id: 260,
        is_compressed: false,
        max_size: 49152028,
        category: PacketCategory::MACHINIMA,
    };
}

codec! {
    pub struct SetMachinimaActorModel {
        pub r#model: Option<Model>,
        pub r#sceneName: Option<String>,
        pub r#actorName: Option<String>,
    }
}

impl Packet for SetMachinimaActorModel {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "SetMachinimaActorModel",
        id: 261,
        is_compressed: false,
        max_size: 1677721600,
        category: PacketCategory::MACHINIMA,
    };
}

codec! {
    pub struct UpdateMachinimaScene {
        pub r#player: Option<String>,
        pub r#sceneName: Option<String>,
        pub r#frame: f32,
        pub r#updateType: SceneUpdateType,
        pub r#scene: Option<Vec<u8>>,
    }
}

impl Packet for UpdateMachinimaScene {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "UpdateMachinimaScene",
        id: 262,
        is_compressed: true,
        max_size: 36864033,
        category: PacketCategory::MACHINIMA,
    };
}

codec! {
    pub enum SceneUpdateType {
        r#Update,
        r#Play,
        r#Stop,
        r#Frame,
        r#Save,
    }
}

codec! {
    pub struct SetServerCamera {
        pub r#clientCameraView: ClientCameraView,
        pub r#isLocked: bool,
        pub r#cameraSettings: Option<ServerCameraSettings>,
    }
}

impl Packet for SetServerCamera {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "SetServerCamera",
        id: 280,
        is_compressed: false,
        max_size: 157,
        category: PacketCategory::CAMERA,
    };
}

codec! {
    pub enum ClientCameraView {
        r#FirstPerson,
        r#ThirdPerson,
        r#Custom,
    }
}

codec! {
    pub struct ServerCameraSettings {
        @small = true;
        pub r#positionLerpSpeed: f32,
        pub r#rotationLerpSpeed: f32,
        pub r#distance: f32,
        pub r#speedModifier: f32,
        pub r#allowPitchControls: bool,
        pub r#displayCursor: bool,
        pub r#displayReticle: bool,
        pub r#mouseInputTargetType: MouseInputTargetType,
        pub r#sendMouseMotion: bool,
        pub r#skipCharacterPhysics: bool,
        pub r#isFirstPerson: bool,
        pub r#movementForceRotationType: MovementForceRotationType,
        pub r#movementForceRotation: Option<Direction>,
        pub r#attachedToType: AttachedToType,
        pub r#attachedToEntityId: u32,
        pub r#eyeOffset: bool,
        pub r#positionDistanceOffsetType: PositionDistanceOffsetType,
        pub r#positionOffset: Option<Position>,
        pub r#rotationOffset: Option<Direction>,
        pub r#positionType: PositionType,
        pub r#position: Option<Position>,
        pub r#rotationType: RotationType,
        pub r#rotation: Option<Direction>,
        pub r#canMoveType: CanMoveType,
        pub r#applyMovementType: ApplyMovementType,
        pub r#movementMultiplier: Option<Vector3f>,
        pub r#applyLookType: ApplyLookType,
        pub r#lookMultiplier: Option<Vector2f>,
        pub r#mouseInputType: MouseInputType,
        pub r#planeNormal: Option<Vector3f>,
    }
}

codec! {
    pub enum MouseInputTargetType {
        r#Any,
        r#Block,
        r#Entity,
        r#None,
    }
}

codec! {
    pub enum MovementForceRotationType {
        r#AttachedToHead,
        r#CameraRotation,
        r#Custom,
    }
}

codec! {
    pub enum AttachedToType {
        r#LocalPlayer,
        r#EntityId,
        r#None,
    }
}

codec! {
    pub enum PositionDistanceOffsetType {
        r#DistanceOffset,
        r#DistanceOffsetRaycast,
        r#None,
    }
}

codec! {
    pub enum PositionType {
        r#AttachedToPlusOffset,
        r#Custom,
    }
}

codec! {
    pub enum RotationType {
        r#AttachedToPlusOffset,
        r#Custom,
    }
}

codec! {
    pub enum CanMoveType {
        r#AttachedToLocalPlayer,
        r#Always,
    }
}

codec! {
    pub enum ApplyMovementType {
        r#CharacterController,
        r#Position,
    }
}

codec! {
    pub enum ApplyLookType {
        r#LocalPlayerLookOrientation,
        r#Rotation,
    }
}

codec! {
    pub enum MouseInputType {
        r#LookAtTarget,
        r#LookAtTargetBlock,
        r#LookAtTargetEntity,
        r#LookAtPlane,
    }
}

codec! {
    pub struct RequestFlyCameraMode {
        pub r#entering: bool,
    }
}

impl Packet for RequestFlyCameraMode {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "RequestFlyCameraMode",
        id: 282,
        is_compressed: false,
        max_size: 1,
        category: PacketCategory::CAMERA,
    };
}

codec! {
    pub struct SetFlyCameraMode {
        pub r#entering: bool,
    }
}

impl Packet for SetFlyCameraMode {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "SetFlyCameraMode",
        id: 283,
        is_compressed: false,
        max_size: 1,
        category: PacketCategory::CAMERA,
    };
}

codec! {
    pub struct SyncInteractionChains {
        pub r#updates: Vec<SyncInteractionChain>,
    }
}

impl Packet for SyncInteractionChains {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "SyncInteractionChains",
        id: 290,
        is_compressed: false,
        max_size: 1677721600,
        category: PacketCategory::INTERACTION,
    };
}

codec! {
    pub struct SyncInteractionChain {
        pub r#activeHotbarSlot: u32,
        pub r#activeUtilitySlot: u32,
        pub r#activeToolsSlot: u32,
        pub r#itemInHandId: Option<String>,
        pub r#utilityItemId: Option<String>,
        pub r#toolsItemId: Option<String>,
        pub r#initial: bool,
        pub r#desync: bool,
        pub r#overrideRootInteraction: u32,
        pub r#interactionType: InteractionType,
        pub r#equipSlot: u32,
        pub r#chainId: u32,
        pub r#forkedId: Option<ForkedChainId>,
        pub r#data: Option<InteractionChainData>,
        pub r#state: InteractionState,
        pub r#newForks: Option<Vec<SyncInteractionChain>>,
        pub r#operationBaseIndex: u32,
        pub r#interactionData: Option<Vec<InteractionSyncData>>,
    }
}

codec! {
    pub struct ForkedChainId {
        pub r#entryIndex: u32,
        pub r#subIndex: u32,
        pub r#forkedId: Option<Box<ForkedChainId>>,
    }
}

codec! {
    pub struct InteractionChainData {
        pub r#entityId: u32,
        pub r#proxyId: Uuid,
        pub r#hitLocation: Option<Vector3f>,
        pub r#hitDetail: Option<String>,
        pub r#blockPosition: Option<BlockPosition>,
        pub r#targetSlot: u32,
        pub r#hitNormal: Option<Vector3f>,
    }
}

codec! {
    pub enum InteractionState {
        r#Finished,
        r#Skip,
        r#ItemChanged,
        r#Failed,
        r#NotFinished,
    }
}

codec! {
    pub struct InteractionSyncData {
        pub r#state: InteractionState,
        pub r#progress: f32,
        pub r#operationCounter: u32,
        pub r#rootInteraction: u32,
        pub r#totalForks: u32,
        pub r#entityId: u32,
        pub r#enteredRootInteraction: u32,
        pub r#blockPosition: Option<BlockPosition>,
        pub r#blockFace: BlockFace,
        pub r#blockRotation: Option<BlockRotation>,
        pub r#placedBlockId: u32,
        pub r#chargeValue: f32,
        pub r#forkCounts: Option<Dictionary<InteractionType, u32>>,
        pub r#chainingIndex: u32,
        pub r#flagIndex: u32,
        pub r#hitEntities: Option<Vec<SelectedHitEntity>>,
        pub r#attackerPos: Option<Position>,
        pub r#attackerRot: Option<Direction>,
        pub r#raycastHit: Option<Position>,
        pub r#raycastDistance: f32,
        pub r#raycastNormal: Option<Vector3f>,
        pub r#movementDirection: MovementDirection,
        pub r#applyForceState: ApplyForceState,
        pub r#nextLabel: u32,
        pub r#generatedUUID: Option<Uuid>,
    }
}

codec! {
    pub struct SelectedHitEntity {
        pub r#networkId: u32,
        pub r#hitLocation: Option<Vector3f>,
        pub r#position: Option<Position>,
        pub r#bodyRotation: Option<Direction>,
    }
}

codec! {
    pub enum MovementDirection {
        r#None,
        r#Forward,
        r#Back,
        r#Left,
        r#Right,
        r#ForwardLeft,
        r#ForwardRight,
        r#BackLeft,
        r#BackRight,
    }
}

codec! {
    pub enum ApplyForceState {
        r#Waiting,
        r#Ground,
        r#Collision,
        r#Timer,
    }
}

codec! {
    pub struct CancelInteractionChain {
        pub r#chainId: u32,
        pub r#forkedId: Option<ForkedChainId>,
    }
}

impl Packet for CancelInteractionChain {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "CancelInteractionChain",
        id: 291,
        is_compressed: false,
        max_size: 1038,
        category: PacketCategory::INTERACTION,
    };
}

codec! {
    pub struct PlayInteractionFor {
        pub r#entityId: u32,
        pub r#chainId: u32,
        pub r#forkedId: Option<ForkedChainId>,
        pub r#operationIndex: u32,
        pub r#interactionId: u32,
        pub r#interactedItemId: Option<String>,
        pub r#interactionType: InteractionType,
        pub r#cancel: bool,
    }
}

impl Packet for PlayInteractionFor {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "PlayInteractionFor",
        id: 292,
        is_compressed: false,
        max_size: 16385065,
        category: PacketCategory::INTERACTION,
    };
}

codec! {
    pub struct MountNPC {
        pub r#anchorX: f32,
        pub r#anchorY: f32,
        pub r#anchorZ: f32,
        pub r#entityId: u32,
    }
}

impl Packet for MountNPC {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "MountNPC",
        id: 293,
        is_compressed: false,
        max_size: 16,
        category: PacketCategory::INTERACTION,
    };
}

codec! {
    pub struct DismountNPC {
    }
}

impl Packet for DismountNPC {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "DismountNPC",
        id: 294,
        is_compressed: false,
        max_size: 0,
        category: PacketCategory::INTERACTION,
    };
}

codec! {
    pub struct FailureReply {
        pub r#token: u32,
        pub r#message: Option<FormattedMessage>,
    }
}

impl Packet for FailureReply {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "FailureReply",
        id: 300,
        is_compressed: false,
        max_size: 1677721600,
        category: PacketCategory::ASSET_EDITOR,
    };
}

codec! {
    pub struct SuccessReply {
        pub r#token: u32,
        pub r#message: Option<FormattedMessage>,
    }
}

impl Packet for SuccessReply {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "SuccessReply",
        id: 301,
        is_compressed: false,
        max_size: 1677721600,
        category: PacketCategory::ASSET_EDITOR,
    };
}

codec! {
    pub struct AssetEditorInitialize {
    }
}

impl Packet for AssetEditorInitialize {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "AssetEditorInitialize",
        id: 302,
        is_compressed: false,
        max_size: 0,
        category: PacketCategory::ASSET_EDITOR,
    };
}

codec! {
    pub struct AssetEditorAuthorization {
        pub r#canUse: bool,
    }
}

impl Packet for AssetEditorAuthorization {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "AssetEditorAuthorization",
        id: 303,
        is_compressed: false,
        max_size: 1,
        category: PacketCategory::ASSET_EDITOR,
    };
}

codec! {
    pub struct AssetEditorCapabilities {
        pub r#canDiscardAssets: bool,
        pub r#canEditAssets: bool,
        pub r#canCreateAssetPacks: bool,
        pub r#canEditAssetPacks: bool,
        pub r#canDeleteAssetPacks: bool,
    }
}

impl Packet for AssetEditorCapabilities {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "AssetEditorCapabilities",
        id: 304,
        is_compressed: false,
        max_size: 5,
        category: PacketCategory::ASSET_EDITOR,
    };
}

codec! {
    pub struct AssetEditorSetupSchemas {
        pub r#schemas: Option<Vec<SchemaFile>>,
    }
}

impl Packet for AssetEditorSetupSchemas {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "AssetEditorSetupSchemas",
        id: 305,
        is_compressed: true,
        max_size: 1677721600,
        category: PacketCategory::ASSET_EDITOR,
    };
}

codec! {
    pub struct SchemaFile {
        pub r#content: Option<String>,
    }
}

codec! {
    pub struct AssetEditorSetupAssetTypes {
        pub r#assetTypes: Option<Vec<AssetEditorAssetType>>,
    }
}

impl Packet for AssetEditorSetupAssetTypes {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "AssetEditorSetupAssetTypes",
        id: 306,
        is_compressed: false,
        max_size: 1677721600,
        category: PacketCategory::ASSET_EDITOR,
    };
}

codec! {
    pub struct AssetEditorAssetType {
        pub r#id: Option<String>,
        pub r#icon: Option<String>,
        pub r#isColoredIcon: bool,
        pub r#path: Option<String>,
        pub r#fileExtension: Option<String>,
        pub r#editorType: AssetEditorEditorType,
    }
}

codec! {
    pub enum AssetEditorEditorType {
        r#None,
        r#Text,
        r#JsonSource,
        r#JsonConfig,
        r#Model,
        r#Texture,
        r#Animation,
    }
}

codec! {
    pub struct AssetEditorCreateDirectory {
        pub r#token: u32,
        pub r#path: Option<AssetPath>,
    }
}

impl Packet for AssetEditorCreateDirectory {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "AssetEditorCreateDirectory",
        id: 307,
        is_compressed: false,
        max_size: 32768024,
        category: PacketCategory::ASSET_EDITOR,
    };
}

codec! {
    pub struct AssetPath {
        pub r#pack: Option<String>,
        pub r#path: Option<String>,
    }
}

codec! {
    pub struct AssetEditorDeleteDirectory {
        pub r#token: u32,
        pub r#path: Option<AssetPath>,
    }
}

impl Packet for AssetEditorDeleteDirectory {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "AssetEditorDeleteDirectory",
        id: 308,
        is_compressed: false,
        max_size: 32768024,
        category: PacketCategory::ASSET_EDITOR,
    };
}

codec! {
    pub struct AssetEditorRenameDirectory {
        pub r#token: u32,
        pub r#path: Option<AssetPath>,
        pub r#newPath: Option<AssetPath>,
    }
}

impl Packet for AssetEditorRenameDirectory {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "AssetEditorRenameDirectory",
        id: 309,
        is_compressed: false,
        max_size: 65536051,
        category: PacketCategory::ASSET_EDITOR,
    };
}

codec! {
    pub struct AssetEditorFetchAsset {
        pub r#token: u32,
        pub r#path: Option<AssetPath>,
        pub r#isFromOpenedTab: bool,
    }
}

impl Packet for AssetEditorFetchAsset {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "AssetEditorFetchAsset",
        id: 310,
        is_compressed: false,
        max_size: 32768025,
        category: PacketCategory::ASSET_EDITOR,
    };
}

codec! {
    pub struct AssetEditorFetchJsonAssetWithParents {
        pub r#token: u32,
        pub r#path: Option<AssetPath>,
        pub r#isFromOpenedTab: bool,
    }
}

impl Packet for AssetEditorFetchJsonAssetWithParents {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "AssetEditorFetchJsonAssetWithParents",
        id: 311,
        is_compressed: false,
        max_size: 32768025,
        category: PacketCategory::ASSET_EDITOR,
    };
}

codec! {
    pub struct AssetEditorFetchAssetReply {
        pub r#token: u32,
        pub r#contents: Option<Vec<u8>>,
    }
}

impl Packet for AssetEditorFetchAssetReply {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "AssetEditorFetchAssetReply",
        id: 312,
        is_compressed: false,
        max_size: 4096010,
        category: PacketCategory::ASSET_EDITOR,
    };
}

codec! {
    pub struct AssetEditorFetchJsonAssetWithParentsReply {
        pub r#token: u32,
        pub r#assets: Option<Dictionary<AssetPath, String>>,
    }
}

impl Packet for AssetEditorFetchJsonAssetWithParentsReply {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "AssetEditorFetchJsonAssetWithParentsReply",
        id: 313,
        is_compressed: true,
        max_size: 1677721600,
        category: PacketCategory::ASSET_EDITOR,
    };
}

codec! {
    pub struct AssetEditorAssetPackSetup {
        pub r#packs: Option<Dictionary<String, AssetPackManifest>>,
    }
}

impl Packet for AssetEditorAssetPackSetup {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "AssetEditorAssetPackSetup",
        id: 314,
        is_compressed: false,
        max_size: 1677721600,
        category: PacketCategory::ASSET_EDITOR,
    };
}

codec! {
    pub struct AssetPackManifest {
        pub r#name: Option<String>,
        pub r#group: Option<String>,
        pub r#website: Option<String>,
        pub r#description: Option<String>,
        pub r#version: Option<String>,
        pub r#authors: Option<Vec<AuthorInfo>>,
    }
}

codec! {
    pub struct AuthorInfo {
        pub r#name: Option<String>,
        pub r#email: Option<String>,
        pub r#url: Option<String>,
    }
}

codec! {
    pub struct AssetEditorUpdateAssetPack {
        pub r#id: Option<String>,
        pub r#manifest: Option<AssetPackManifest>,
    }
}

impl Packet for AssetEditorUpdateAssetPack {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "AssetEditorUpdateAssetPack",
        id: 315,
        is_compressed: false,
        max_size: 1677721600,
        category: PacketCategory::ASSET_EDITOR,
    };
}

codec! {
    pub struct AssetEditorCreateAssetPack {
        pub r#token: u32,
        pub r#manifest: Option<AssetPackManifest>,
    }
}

impl Packet for AssetEditorCreateAssetPack {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "AssetEditorCreateAssetPack",
        id: 316,
        is_compressed: false,
        max_size: 1677721600,
        category: PacketCategory::ASSET_EDITOR,
    };
}

codec! {
    pub struct AssetEditorDeleteAssetPack {
        pub r#id: Option<String>,
    }
}

impl Packet for AssetEditorDeleteAssetPack {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "AssetEditorDeleteAssetPack",
        id: 317,
        is_compressed: false,
        max_size: 16384006,
        category: PacketCategory::ASSET_EDITOR,
    };
}

codec! {
    pub struct AssetEditorEnableAssetPack {
        pub r#id: Option<String>,
        pub r#enabled: bool,
    }
}

impl Packet for AssetEditorEnableAssetPack {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "AssetEditorEnableAssetPack",
        id: 318,
        is_compressed: false,
        max_size: 16384007,
        category: PacketCategory::ASSET_EDITOR,
    };
}

codec! {
    pub struct AssetEditorAssetListSetup {
        pub r#pack: Option<String>,
        pub r#isReadOnly: bool,
        pub r#canBeDeleted: bool,
        pub r#tree: AssetEditorFileTree,
        pub r#paths: Option<Vec<AssetEditorFileEntry>>,
    }
}

impl Packet for AssetEditorAssetListSetup {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "AssetEditorAssetListSetup",
        id: 319,
        is_compressed: true,
        max_size: 1677721600,
        category: PacketCategory::ASSET_EDITOR,
    };
}

codec! {
    pub enum AssetEditorFileTree {
        r#Server,
        r#Common,
    }
}

codec! {
    pub struct AssetEditorFileEntry {
        pub r#path: Option<String>,
        pub r#isDirectory: bool,
    }
}

codec! {
    pub struct AssetEditorAssetListUpdate {
        pub r#pack: Option<String>,
        pub r#additions: Option<Vec<AssetEditorFileEntry>>,
        pub r#deletions: Option<Vec<AssetEditorFileEntry>>,
    }
}

impl Packet for AssetEditorAssetListUpdate {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "AssetEditorAssetListUpdate",
        id: 320,
        is_compressed: true,
        max_size: 1677721600,
        category: PacketCategory::ASSET_EDITOR,
    };
}

codec! {
    pub struct AssetEditorRequestChildrenList {
        pub r#path: Option<AssetPath>,
    }
}

impl Packet for AssetEditorRequestChildrenList {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "AssetEditorRequestChildrenList",
        id: 321,
        is_compressed: false,
        max_size: 32768020,
        category: PacketCategory::ASSET_EDITOR,
    };
}

codec! {
    pub struct AssetEditorRequestChildrenListReply {
        pub r#path: Option<AssetPath>,
        pub r#childrenIds: Option<Vec<String>>,
    }
}

impl Packet for AssetEditorRequestChildrenListReply {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "AssetEditorRequestChildrenListReply",
        id: 322,
        is_compressed: false,
        max_size: 1677721600,
        category: PacketCategory::ASSET_EDITOR,
    };
}

codec! {
    pub struct AssetEditorUpdateJsonAsset {
        pub r#token: u32,
        pub r#assetType: Option<String>,
        pub r#path: Option<AssetPath>,
        pub r#assetIndex: u32,
        pub r#commands: Option<Vec<JsonUpdateCommand>>,
    }
}

impl Packet for AssetEditorUpdateJsonAsset {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "AssetEditorUpdateJsonAsset",
        id: 323,
        is_compressed: true,
        max_size: 1677721600,
        category: PacketCategory::ASSET_EDITOR,
    };
}

codec! {
    pub struct JsonUpdateCommand {
        pub r#type: JsonUpdateType,
        pub r#path: Option<Vec<String>>,
        pub r#value: Option<String>,
        pub r#previousValue: Option<String>,
        pub r#firstCreatedProperty: Option<Vec<String>>,
        pub r#rebuildCaches: Option<AssetEditorRebuildCaches>,
    }
}

codec! {
    pub enum JsonUpdateType {
        r#SetProperty,
        r#InsertProperty,
        r#RemoveProperty,
    }
}

codec! {
    pub struct AssetEditorRebuildCaches {
        @small = true;
        pub r#blockTextures: bool,
        pub r#models: bool,
        pub r#modelTextures: bool,
        pub r#mapGeometry: bool,
        pub r#itemIcons: bool,
    }
}

impl Packet for AssetEditorRebuildCaches {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "AssetEditorRebuildCaches",
        id: 348,
        is_compressed: false,
        max_size: 5,
        category: PacketCategory::ASSET_EDITOR,
    };
}

codec! {
    pub struct AssetEditorUpdateAsset {
        pub r#token: u32,
        pub r#assetType: Option<String>,
        pub r#path: Option<AssetPath>,
        pub r#assetIndex: u32,
        pub r#data: Option<Vec<u8>>,
    }
}

impl Packet for AssetEditorUpdateAsset {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "AssetEditorUpdateAsset",
        id: 324,
        is_compressed: false,
        max_size: 53248050,
        category: PacketCategory::ASSET_EDITOR,
    };
}

codec! {
    pub struct AssetEditorJsonAssetUpdated {
        pub r#path: Option<AssetPath>,
        pub r#commands: Option<Vec<JsonUpdateCommand>>,
    }
}

impl Packet for AssetEditorJsonAssetUpdated {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "AssetEditorJsonAssetUpdated",
        id: 325,
        is_compressed: false,
        max_size: 1677721600,
        category: PacketCategory::ASSET_EDITOR,
    };
}

codec! {
    pub struct AssetEditorAssetUpdated {
        pub r#path: Option<AssetPath>,
        pub r#data: Option<Vec<u8>>,
    }
}

impl Packet for AssetEditorAssetUpdated {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "AssetEditorAssetUpdated",
        id: 326,
        is_compressed: false,
        max_size: 36864033,
        category: PacketCategory::ASSET_EDITOR,
    };
}

codec! {
    pub struct AssetEditorCreateAsset {
        pub r#token: u32,
        pub r#path: Option<AssetPath>,
        pub r#data: Option<Vec<u8>>,
        pub r#rebuildCaches: Option<AssetEditorRebuildCaches>,
        pub r#buttonId: Option<String>,
    }
}

impl Packet for AssetEditorCreateAsset {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "AssetEditorCreateAsset",
        id: 327,
        is_compressed: false,
        max_size: 53248051,
        category: PacketCategory::ASSET_EDITOR,
    };
}

codec! {
    pub struct AssetEditorRenameAsset {
        pub r#token: u32,
        pub r#path: Option<AssetPath>,
        pub r#newPath: Option<AssetPath>,
    }
}

impl Packet for AssetEditorRenameAsset {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "AssetEditorRenameAsset",
        id: 328,
        is_compressed: false,
        max_size: 65536051,
        category: PacketCategory::ASSET_EDITOR,
    };
}

codec! {
    pub struct AssetEditorDeleteAsset {
        pub r#token: u32,
        pub r#path: Option<AssetPath>,
    }
}

impl Packet for AssetEditorDeleteAsset {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "AssetEditorDeleteAsset",
        id: 329,
        is_compressed: false,
        max_size: 32768024,
        category: PacketCategory::ASSET_EDITOR,
    };
}

codec! {
    pub struct AssetEditorDiscardChanges {
        pub r#assets: Option<Vec<TimestampedAssetReference>>,
    }
}

impl Packet for AssetEditorDiscardChanges {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "AssetEditorDiscardChanges",
        id: 330,
        is_compressed: false,
        max_size: 1677721600,
        category: PacketCategory::ASSET_EDITOR,
    };
}

codec! {
    pub struct TimestampedAssetReference {
        pub r#path: Option<AssetPath>,
        pub r#timestamp: Option<String>,
    }
}

codec! {
    pub struct AssetEditorFetchAutoCompleteData {
        pub r#token: u32,
        pub r#dataset: Option<String>,
        pub r#query: Option<String>,
    }
}

impl Packet for AssetEditorFetchAutoCompleteData {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "AssetEditorFetchAutoCompleteData",
        id: 331,
        is_compressed: false,
        max_size: 32768023,
        category: PacketCategory::ASSET_EDITOR,
    };
}

codec! {
    pub struct AssetEditorFetchAutoCompleteDataReply {
        pub r#token: u32,
        pub r#results: Option<Vec<String>>,
    }
}

impl Packet for AssetEditorFetchAutoCompleteDataReply {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "AssetEditorFetchAutoCompleteDataReply",
        id: 332,
        is_compressed: false,
        max_size: 1677721600,
        category: PacketCategory::ASSET_EDITOR,
    };
}

codec! {
    pub struct AssetEditorRequestDataset {
        pub r#name: Option<String>,
    }
}

impl Packet for AssetEditorRequestDataset {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "AssetEditorRequestDataset",
        id: 333,
        is_compressed: false,
        max_size: 16384006,
        category: PacketCategory::ASSET_EDITOR,
    };
}

codec! {
    pub struct AssetEditorRequestDatasetReply {
        pub r#name: Option<String>,
        pub r#ids: Option<Vec<String>>,
    }
}

impl Packet for AssetEditorRequestDatasetReply {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "AssetEditorRequestDatasetReply",
        id: 334,
        is_compressed: false,
        max_size: 1677721600,
        category: PacketCategory::ASSET_EDITOR,
    };
}

codec! {
    pub struct AssetEditorActivateButton {
        pub r#buttonId: Option<String>,
    }
}

impl Packet for AssetEditorActivateButton {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "AssetEditorActivateButton",
        id: 335,
        is_compressed: false,
        max_size: 16384006,
        category: PacketCategory::ASSET_EDITOR,
    };
}

codec! {
    pub struct AssetEditorSelectAsset {
        pub r#path: Option<AssetPath>,
    }
}

impl Packet for AssetEditorSelectAsset {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "AssetEditorSelectAsset",
        id: 336,
        is_compressed: false,
        max_size: 32768020,
        category: PacketCategory::ASSET_EDITOR,
    };
}

codec! {
    pub struct AssetEditorPopupNotification {
        pub r#type: AssetEditorPopupNotificationType,
        pub r#message: Option<FormattedMessage>,
    }
}

impl Packet for AssetEditorPopupNotification {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "AssetEditorPopupNotification",
        id: 337,
        is_compressed: false,
        max_size: 1677721600,
        category: PacketCategory::ASSET_EDITOR,
    };
}

codec! {
    pub enum AssetEditorPopupNotificationType {
        r#Info,
        r#Success,
        r#Error,
        r#Warning,
    }
}

codec! {
    pub struct AssetEditorFetchLastModifiedAssets {
    }
}

impl Packet for AssetEditorFetchLastModifiedAssets {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "AssetEditorFetchLastModifiedAssets",
        id: 338,
        is_compressed: false,
        max_size: 0,
        category: PacketCategory::ASSET_EDITOR,
    };
}

codec! {
    pub struct AssetEditorLastModifiedAssets {
        pub r#assets: Option<Vec<AssetInfo>>,
    }
}

impl Packet for AssetEditorLastModifiedAssets {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "AssetEditorLastModifiedAssets",
        id: 339,
        is_compressed: false,
        max_size: 1677721600,
        category: PacketCategory::ASSET_EDITOR,
    };
}

codec! {
    pub struct AssetInfo {
        pub r#path: Option<AssetPath>,
        pub r#oldPath: Option<AssetPath>,
        pub r#isDeleted: bool,
        pub r#isNew: bool,
        pub r#lastModificationDate: u64,
        pub r#lastModificationUsername: Option<String>,
    }
}

codec! {
    pub struct AssetEditorModifiedAssetsCount {
        pub r#count: u32,
    }
}

impl Packet for AssetEditorModifiedAssetsCount {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "AssetEditorModifiedAssetsCount",
        id: 340,
        is_compressed: false,
        max_size: 4,
        category: PacketCategory::ASSET_EDITOR,
    };
}

codec! {
    pub struct AssetEditorSubscribeModifiedAssetsChanges {
        pub r#subscribe: bool,
    }
}

impl Packet for AssetEditorSubscribeModifiedAssetsChanges {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "AssetEditorSubscribeModifiedAssetsChanges",
        id: 341,
        is_compressed: false,
        max_size: 1,
        category: PacketCategory::ASSET_EDITOR,
    };
}

codec! {
    pub struct AssetEditorExportAssets {
        pub r#paths: Option<Vec<AssetPath>>,
    }
}

impl Packet for AssetEditorExportAssets {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "AssetEditorExportAssets",
        id: 342,
        is_compressed: false,
        max_size: 1677721600,
        category: PacketCategory::ASSET_EDITOR,
    };
}

codec! {
    pub struct AssetEditorExportAssetInitialize {
        pub r#asset: Option<AssetEditorAsset>,
        pub r#oldPath: Option<AssetPath>,
        pub r#size: u32,
        pub r#failed: bool,
    }
}

impl Packet for AssetEditorExportAssetInitialize {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "AssetEditorExportAssetInitialize",
        id: 343,
        is_compressed: false,
        max_size: 81920066,
        category: PacketCategory::ASSET_EDITOR,
    };
}

codec! {
    pub struct AssetEditorAsset {
        pub r#hash: Option<String>,
        pub r#path: Option<AssetPath>,
    }
}

codec! {
    pub struct AssetEditorExportAssetPart {
        pub r#part: Option<Vec<u8>>,
    }
}

impl Packet for AssetEditorExportAssetPart {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "AssetEditorExportAssetPart",
        id: 344,
        is_compressed: true,
        max_size: 4096006,
        category: PacketCategory::ASSET_EDITOR,
    };
}

codec! {
    pub struct AssetEditorExportAssetFinalize {
    }
}

impl Packet for AssetEditorExportAssetFinalize {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "AssetEditorExportAssetFinalize",
        id: 345,
        is_compressed: false,
        max_size: 0,
        category: PacketCategory::ASSET_EDITOR,
    };
}

codec! {
    pub struct AssetEditorExportDeleteAssets {
        pub r#asset: Option<Vec<AssetEditorAsset>>,
    }
}

impl Packet for AssetEditorExportDeleteAssets {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "AssetEditorExportDeleteAssets",
        id: 346,
        is_compressed: false,
        max_size: 1677721600,
        category: PacketCategory::ASSET_EDITOR,
    };
}

codec! {
    pub struct AssetEditorExportComplete {
        pub r#assets: Option<Vec<TimestampedAssetReference>>,
    }
}

impl Packet for AssetEditorExportComplete {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "AssetEditorExportComplete",
        id: 347,
        is_compressed: false,
        max_size: 1677721600,
        category: PacketCategory::ASSET_EDITOR,
    };
}

codec! {
    pub struct AssetEditorUndoChanges {
        pub r#token: u32,
        pub r#path: Option<AssetPath>,
    }
}

impl Packet for AssetEditorUndoChanges {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "AssetEditorUndoChanges",
        id: 349,
        is_compressed: false,
        max_size: 32768024,
        category: PacketCategory::ASSET_EDITOR,
    };
}

codec! {
    pub struct AssetEditorRedoChanges {
        pub r#token: u32,
        pub r#path: Option<AssetPath>,
    }
}

impl Packet for AssetEditorRedoChanges {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "AssetEditorRedoChanges",
        id: 350,
        is_compressed: false,
        max_size: 32768024,
        category: PacketCategory::ASSET_EDITOR,
    };
}

codec! {
    pub struct AssetEditorUndoRedoReply {
        pub r#token: u32,
        pub r#command: Option<JsonUpdateCommand>,
    }
}

impl Packet for AssetEditorUndoRedoReply {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "AssetEditorUndoRedoReply",
        id: 351,
        is_compressed: false,
        max_size: 1677721600,
        category: PacketCategory::ASSET_EDITOR,
    };
}

codec! {
    pub struct AssetEditorSetGameTime {
        pub r#gameTime: Option<InstantData>,
        pub r#paused: bool,
    }
}

impl Packet for AssetEditorSetGameTime {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "AssetEditorSetGameTime",
        id: 352,
        is_compressed: false,
        max_size: 14,
        category: PacketCategory::ASSET_EDITOR,
    };
}

codec! {
    pub struct AssetEditorUpdateSecondsPerGameDay {
        pub r#daytimeDurationSeconds: u32,
        pub r#nighttimeDurationSeconds: u32,
    }
}

impl Packet for AssetEditorUpdateSecondsPerGameDay {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "AssetEditorUpdateSecondsPerGameDay",
        id: 353,
        is_compressed: false,
        max_size: 8,
        category: PacketCategory::ASSET_EDITOR,
    };
}

codec! {
    pub struct AssetEditorUpdateWeatherPreviewLock {
        pub r#locked: bool,
    }
}

impl Packet for AssetEditorUpdateWeatherPreviewLock {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "AssetEditorUpdateWeatherPreviewLock",
        id: 354,
        is_compressed: false,
        max_size: 1,
        category: PacketCategory::ASSET_EDITOR,
    };
}

codec! {
    pub struct AssetEditorUpdateModelPreview {
        pub r#assetPath: Option<AssetPath>,
        pub r#model: Option<Model>,
        pub r#block: Option<BlockType>,
        pub r#camera: Option<AssetEditorPreviewCameraSettings>,
    }
}

impl Packet for AssetEditorUpdateModelPreview {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "AssetEditorUpdateModelPreview",
        id: 355,
        is_compressed: false,
        max_size: 1677721600,
        category: PacketCategory::ASSET_EDITOR,
    };
}

codec! {
    pub struct AssetEditorPreviewCameraSettings {
        @small = true;
        pub r#modelScale: f32,
        pub r#cameraPosition: Option<Vector3f>,
        pub r#cameraOrientation: Option<Vector3f>,
    }
}

codec! {
    pub struct UpdateSunSettings {
        pub r#heightPercentage: f32,
        pub r#angleRadians: f32,
    }
}

impl Packet for UpdateSunSettings {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "UpdateSunSettings",
        id: 360,
        is_compressed: false,
        max_size: 8,
        category: PacketCategory::WORLD,
    };
}

codec! {
    pub struct UpdatePostFxSettings {
        pub r#globalIntensity: f32,
        pub r#power: f32,
        pub r#sunshaftScale: f32,
        pub r#sunIntensity: f32,
        pub r#sunshaftIntensity: f32,
    }
}

impl Packet for UpdatePostFxSettings {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "UpdatePostFxSettings",
        id: 361,
        is_compressed: false,
        max_size: 20,
        category: PacketCategory::WORLD,
    };
}

codec! {
    pub struct BuilderToolArgUpdate {
        pub r#token: u32,
        pub r#section: u32,
        pub r#slot: u32,
        pub r#group: BuilderToolArgGroup,
        pub r#id: Option<String>,
        pub r#value: Option<String>,
    }
}

impl Packet for BuilderToolArgUpdate {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "BuilderToolArgUpdate",
        id: 400,
        is_compressed: false,
        max_size: 32768032,
        category: PacketCategory::BUILDER_TOOLS,
    };
}

codec! {
    pub enum BuilderToolArgGroup {
        r#Tool,
        r#Brush,
    }
}

codec! {
    pub struct BuilderToolEntityAction {
        pub r#entityId: u32,
        pub r#action: EntityToolAction,
    }
}

impl Packet for BuilderToolEntityAction {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "BuilderToolEntityAction",
        id: 401,
        is_compressed: false,
        max_size: 5,
        category: PacketCategory::BUILDER_TOOLS,
    };
}

codec! {
    pub enum EntityToolAction {
        r#Remove,
        r#Clone,
        r#Freeze,
    }
}

codec! {
    pub struct BuilderToolSetEntityTransform {
        pub r#entityId: u32,
        pub r#modelTransform: Option<ModelTransform>,
    }
}

impl Packet for BuilderToolSetEntityTransform {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "BuilderToolSetEntityTransform",
        id: 402,
        is_compressed: false,
        max_size: 54,
        category: PacketCategory::BUILDER_TOOLS,
    };
}

codec! {
    pub struct BuilderToolExtrudeAction {
        pub r#x: u32,
        pub r#y: u32,
        pub r#z: u32,
        pub r#xNormal: u32,
        pub r#yNormal: u32,
        pub r#zNormal: u32,
    }
}

impl Packet for BuilderToolExtrudeAction {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "BuilderToolExtrudeAction",
        id: 403,
        is_compressed: false,
        max_size: 24,
        category: PacketCategory::BUILDER_TOOLS,
    };
}

codec! {
    pub struct BuilderToolStackArea {
        pub r#selectionMin: Option<BlockPosition>,
        pub r#selectionMax: Option<BlockPosition>,
        pub r#xNormal: u32,
        pub r#yNormal: u32,
        pub r#zNormal: u32,
        pub r#numStacks: u32,
    }
}

impl Packet for BuilderToolStackArea {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "BuilderToolStackArea",
        id: 404,
        is_compressed: false,
        max_size: 41,
        category: PacketCategory::BUILDER_TOOLS,
    };
}

codec! {
    pub struct BuilderToolSelectionTransform {
        pub r#transformationMatrix: Option<Vec<f32>>,
        pub r#initialSelectionMin: Option<BlockPosition>,
        pub r#initialSelectionMax: Option<BlockPosition>,
        pub r#initialRotationOrigin: Option<Vector3f>,
        pub r#cutOriginal: bool,
        pub r#applyTransformationToSelectionMinMax: bool,
        pub r#isExitingTransformMode: bool,
        pub r#initialPastePointForClipboardPaste: Option<BlockPosition>,
    }
}

impl Packet for BuilderToolSelectionTransform {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "BuilderToolSelectionTransform",
        id: 405,
        is_compressed: false,
        max_size: 16384057,
        category: PacketCategory::BUILDER_TOOLS,
    };
}

codec! {
    pub struct BuilderToolRotateClipboard {
        pub r#angle: u32,
        pub r#axis: Axis,
    }
}

impl Packet for BuilderToolRotateClipboard {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "BuilderToolRotateClipboard",
        id: 406,
        is_compressed: false,
        max_size: 5,
        category: PacketCategory::BUILDER_TOOLS,
    };
}

codec! {
    pub enum Axis {
        r#X,
        r#Y,
        r#Z,
    }
}

codec! {
    pub struct BuilderToolPasteClipboard {
        pub r#x: u32,
        pub r#y: u32,
        pub r#z: u32,
    }
}

impl Packet for BuilderToolPasteClipboard {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "BuilderToolPasteClipboard",
        id: 407,
        is_compressed: false,
        max_size: 12,
        category: PacketCategory::BUILDER_TOOLS,
    };
}

codec! {
    pub struct BuilderToolSetTransformationModeState {
        pub r#enabled: bool,
    }
}

impl Packet for BuilderToolSetTransformationModeState {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "BuilderToolSetTransformationModeState",
        id: 408,
        is_compressed: false,
        max_size: 1,
        category: PacketCategory::BUILDER_TOOLS,
    };
}

codec! {
    pub struct BuilderToolSelectionUpdate {
        pub r#xMin: u32,
        pub r#yMin: u32,
        pub r#zMin: u32,
        pub r#xMax: u32,
        pub r#yMax: u32,
        pub r#zMax: u32,
    }
}

impl Packet for BuilderToolSelectionUpdate {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "BuilderToolSelectionUpdate",
        id: 409,
        is_compressed: false,
        max_size: 24,
        category: PacketCategory::BUILDER_TOOLS,
    };
}

codec! {
    pub struct BuilderToolSelectionToolAskForClipboard {
    }
}

impl Packet for BuilderToolSelectionToolAskForClipboard {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "BuilderToolSelectionToolAskForClipboard",
        id: 410,
        is_compressed: false,
        max_size: 0,
        category: PacketCategory::BUILDER_TOOLS,
    };
}

codec! {
    pub struct BuilderToolSelectionToolReplyWithClipboard {
        pub r#blocksChange: Option<Vec<BlockChange>>,
        pub r#fluidsChange: Option<Vec<FluidChange>>,
    }
}

impl Packet for BuilderToolSelectionToolReplyWithClipboard {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "BuilderToolSelectionToolReplyWithClipboard",
        id: 411,
        is_compressed: true,
        max_size: 139264019,
        category: PacketCategory::BUILDER_TOOLS,
    };
}

codec! {
    pub struct BuilderToolGeneralAction {
        pub r#action: BuilderToolAction,
    }
}

impl Packet for BuilderToolGeneralAction {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "BuilderToolGeneralAction",
        id: 412,
        is_compressed: false,
        max_size: 1,
        category: PacketCategory::BUILDER_TOOLS,
    };
}

codec! {
    pub enum BuilderToolAction {
        r#SelectionPosition1,
        r#SelectionPosition2,
        r#SelectionCopy,
        r#HistoryUndo,
        r#HistoryRedo,
        r#ActivateToolMode,
        r#DeactivateToolMode,
    }
}

codec! {
    pub struct BuilderToolOnUseInteraction {
        pub r#type: InteractionType,
        pub r#x: u32,
        pub r#y: u32,
        pub r#z: u32,
        pub r#offsetForPaintModeX: u32,
        pub r#offsetForPaintModeY: u32,
        pub r#offsetForPaintModeZ: u32,
        pub r#isAltPlaySculptBrushModDown: bool,
        pub r#isHoldDownInteraction: bool,
        pub r#isDoServerRaytraceForPosition: bool,
        pub r#isShowEditNotifications: bool,
        pub r#maxLengthToolIgnoreHistory: u32,
        pub r#raycastOriginX: f32,
        pub r#raycastOriginY: f32,
        pub r#raycastOriginZ: f32,
        pub r#raycastDirectionX: f32,
        pub r#raycastDirectionY: f32,
        pub r#raycastDirectionZ: f32,
    }
}

impl Packet for BuilderToolOnUseInteraction {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "BuilderToolOnUseInteraction",
        id: 413,
        is_compressed: false,
        max_size: 57,
        category: PacketCategory::BUILDER_TOOLS,
    };
}

codec! {
    pub struct BuilderToolLineAction {
        pub r#xStart: u32,
        pub r#yStart: u32,
        pub r#zStart: u32,
        pub r#xEnd: u32,
        pub r#yEnd: u32,
        pub r#zEnd: u32,
    }
}

impl Packet for BuilderToolLineAction {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "BuilderToolLineAction",
        id: 414,
        is_compressed: false,
        max_size: 24,
        category: PacketCategory::BUILDER_TOOLS,
    };
}

codec! {
    pub struct BuilderToolShowAnchor {
        pub r#x: u32,
        pub r#y: u32,
        pub r#z: u32,
    }
}

impl Packet for BuilderToolShowAnchor {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "BuilderToolShowAnchor",
        id: 415,
        is_compressed: false,
        max_size: 12,
        category: PacketCategory::BUILDER_TOOLS,
    };
}

codec! {
    pub struct BuilderToolHideAnchors {
    }
}

impl Packet for BuilderToolHideAnchors {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "BuilderToolHideAnchors",
        id: 416,
        is_compressed: false,
        max_size: 0,
        category: PacketCategory::BUILDER_TOOLS,
    };
}

codec! {
    pub struct PrefabUnselectPrefab {
    }
}

impl Packet for PrefabUnselectPrefab {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "PrefabUnselectPrefab",
        id: 417,
        is_compressed: false,
        max_size: 0,
        category: PacketCategory::BUILDER_TOOLS,
    };
}

codec! {
    pub struct BuilderToolsSetSoundSet {
        pub r#soundSetIndex: u32,
    }
}

impl Packet for BuilderToolsSetSoundSet {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "BuilderToolsSetSoundSet",
        id: 418,
        is_compressed: false,
        max_size: 4,
        category: PacketCategory::BUILDER_TOOLS,
    };
}

codec! {
    pub struct BuilderToolLaserPointer {
        pub r#playerNetworkId: u32,
        pub r#startX: f32,
        pub r#startY: f32,
        pub r#startZ: f32,
        pub r#endX: f32,
        pub r#endY: f32,
        pub r#endZ: f32,
        pub r#color: u32,
        pub r#durationMs: u32,
    }
}

impl Packet for BuilderToolLaserPointer {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "BuilderToolLaserPointer",
        id: 419,
        is_compressed: false,
        max_size: 36,
        category: PacketCategory::BUILDER_TOOLS,
    };
}

codec! {
    pub struct BuilderToolSetEntityScale {
        pub r#entityId: u32,
        pub r#scale: f32,
    }
}

impl Packet for BuilderToolSetEntityScale {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "BuilderToolSetEntityScale",
        id: 420,
        is_compressed: false,
        max_size: 8,
        category: PacketCategory::BUILDER_TOOLS,
    };
}

codec! {
    pub struct BuilderToolSetEntityPickupEnabled {
        pub r#entityId: u32,
        pub r#enabled: bool,
    }
}

impl Packet for BuilderToolSetEntityPickupEnabled {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "BuilderToolSetEntityPickupEnabled",
        id: 421,
        is_compressed: false,
        max_size: 5,
        category: PacketCategory::BUILDER_TOOLS,
    };
}

codec! {
    pub struct BuilderToolSetEntityLight {
        pub r#entityId: u32,
        pub r#light: Option<ColorLight>,
    }
}

impl Packet for BuilderToolSetEntityLight {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "BuilderToolSetEntityLight",
        id: 422,
        is_compressed: false,
        max_size: 9,
        category: PacketCategory::BUILDER_TOOLS,
    };
}

codec! {
    pub struct BuilderToolSetNPCDebug {
        pub r#entityId: u32,
        pub r#enabled: bool,
    }
}

impl Packet for BuilderToolSetNPCDebug {
    const DESCRIPTOR: &'static PacketDescriptor = &PacketDescriptor {
        name: "BuilderToolSetNPCDebug",
        id: 423,
        is_compressed: false,
        max_size: 5,
        category: PacketCategory::BUILDER_TOOLS,
    };
}

